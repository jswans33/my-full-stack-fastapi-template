This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
__init__.py
cli.py
config.py
entry_point.py
factories.py
filesystem.py
generator/plantuml-generator.py
interfaces.py
models.py
parsers/python_parser.py
service.py

================================================================
Files
================================================================

================
File: __init__.py
================
"""UML Generator package for creating UML diagrams from source code."""

__version__ = "0.1.0"

================
File: cli.py
================
import argparse
from pathlib import Path

from .config import Configuration, create_config_from_args, configure_logging
from .filesystem import DefaultFileSystem
from .factories import DefaultParserFactory, DefaultGeneratorFactory
from .service import UmlGeneratorService


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    # Get the script directory for default paths
    script_dir = Path(__file__).resolve().parent
    project_root = script_dir.parent
    default_output_dir = project_root.parent / "docs" / "source" / "_generated_uml"
    
    parser = argparse.ArgumentParser(
        description="Generate UML class diagrams from source code.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        epilog="""
Examples:
  # Process a single file
  python -m uml_generator -f backend/app/models.py
  
  # Process a directory
  python -m uml_generator -d backend/app
  
  # Process the app directory
  python -m uml_generator --app-dir
  
  # Process a directory recursively
  python -m uml_generator -d backend/app --recursive
  
  # Specify a custom output directory
  python -m uml_generator -d backend/app -o custom/output/path
  
  # Enable verbose logging
  python -m uml_generator -d backend/app -v
  
For more information, see the README.md file.
        """,
    )
    
    # Create a mutually exclusive group for input sources
    input_group = parser.add_mutually_exclusive_group(required=True)
    
    input_group.add_argument(
        "-f",
        "--file",
        help="Process a single source file",
    )
    
    input_group.add_argument(
        "-d",
        "--directory",
        help="Process a directory containing source files",
    )
    
    input_group.add_argument(
        "--app-dir",
        action="store_true",
        help="Process the app directory (default location)",
    )
    
    # Output options
    parser.add_argument(
        "-o",
        "--output",
        default=str(default_output_dir),
        help="Output directory for UML files",
    )
    
    parser.add_argument(
        "--format",
        choices=["plantuml"],
        default="plantuml",
        help="Output format for UML diagrams",
    )
    
    # Processing options
    parser.add_argument(
        "--subdirs",
        nargs="+",
        default=["models", "services"],
        help="List of subdirectories to process (only with --directory or --app-dir)",
    )
    
    parser.add_argument(
        "--recursive",
        action="store_true",
        help="Recursively process directories",
    )
    
    parser.add_argument(
        "--list-only",
        action="store_true",
        help="Only list files without generating UML diagrams (for troubleshooting)",
    )
    
    parser.add_argument(
        "--show-imports",
        action="store_true",
        help="Show imports in the UML diagrams",
    )
    
    parser.add_argument(
        "--generate-report",
        action="store_true",
        help="Generate a report of files processed",
    )
    
    # Verbosity options
    verbosity_group = parser.add_mutually_exclusive_group()
    verbosity_group.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output",
    )
    
    verbosity_group.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Suppress all output except errors",
    )
    
    verbosity_group.add_argument(
        "--debug",
        action="store_true",
        help="Enable debug logging",
    )
    
    return parser.parse_args()


def main() -> None:
    """Main entry point for the UML generator."""
    # Parse command-line arguments
    args = parse_args()
    
    # Configure logging
    logger = configure_logging(args)
    
    # Create configuration
    config = create_config_from_args(args)
    
    # Create dependencies
    file_system = DefaultFileSystem()
    parser_factory = DefaultParserFactory(file_system)
    generator_factory = DefaultGeneratorFactory(file_system, config.plantuml_settings)
    
    # Create and run the service
    service = UmlGeneratorService(
        config=config,
        file_system=file_system,
        parser_factory=parser_factory,
        generator_factory=generator_factory,
        logger=logger,
    )
    
    service.run()


if __name__ == "__main__":
    main()

================
File: config.py
================
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from pathlib import Path
import os
import logging


@dataclass
class Configuration:
    """Configuration for the UML generator."""
    # Input/output settings
    source_dir: Path
    output_dir: Path
    single_file: Optional[Path] = None
    input_extension: str = ".py"
    output_format: str = "plantuml"
    
    # Processing options
    subdirs: List[str] = field(default_factory=lambda: ["models", "services"])
    recursive: bool = False
    list_only: bool = False
    show_imports: bool = False
    generate_report: bool = False
    
    # PlantUML specific settings
    plantuml_settings: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Initialize default settings and ensure directories exist."""
        # Ensure paths are Path objects
        if isinstance(self.source_dir, str):
            self.source_dir = Path(self.source_dir)
        
        if isinstance(self.output_dir, str):
            self.output_dir = Path(self.output_dir)
        
        if self.single_file and isinstance(self.single_file, str):
            self.single_file = Path(self.single_file)
        
        # Set default PlantUML settings if not provided
        if not self.plantuml_settings:
            self.plantuml_settings = {
                'PLANTUML_START': "@startuml",
                'PLANTUML_END': "@enduml",
                'PLANTUML_SETTINGS': [
                    "skinparam classAttributeIconSize 0",
                ],
                'show_imports': self.show_imports,
            }
        
        # Ensure output directory exists
        os.makedirs(self.output_dir, exist_ok=True)


def create_config_from_args(args) -> Configuration:
    """Create configuration from command line arguments."""
    # Determine source directory
    if hasattr(args, 'file') and args.file:
        source_dir = Path(args.file).parent
        single_file = Path(args.file)
    elif hasattr(args, 'directory') and args.directory:
        source_dir = Path(args.directory)
        single_file = None
    elif hasattr(args, 'app_dir') and args.app_dir:
        script_dir = Path(__file__).resolve().parent
        project_root = script_dir.parent
        source_dir = project_root / "app"
        single_file = None
    else:
        raise ValueError("No source directory or file specified")
    
    # Create configuration
    config = Configuration(
        source_dir=source_dir,
        output_dir=Path(args.output),
        single_file=single_file,
        subdirs=args.subdirs if hasattr(args, 'subdirs') else None,
        recursive=args.recursive if hasattr(args, 'recursive') else False,
        list_only=args.list_only if hasattr(args, 'list_only') else False,
        show_imports=args.show_imports if hasattr(args, 'show_imports') else False,
        generate_report=args.generate_report if hasattr(args, 'generate_report') else False,
    )
    
    return config


def configure_logging(args) -> logging.Logger:
    """Configure logging based on command line arguments."""
    logger = logging.getLogger("uml_generator")
    
    # Configure handler if not already configured
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s - %(levelname)s - %(name)s - %(message)s"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    # Set log level based on verbosity
    if hasattr(args, 'debug') and args.debug:
        logger.setLevel(logging.DEBUG)
    elif hasattr(args, 'verbose') and args.verbose:
        logger.setLevel(logging.INFO)
    elif hasattr(args, 'quiet') and args.quiet:
        logger.setLevel(logging.ERROR)
    else:
        logger.setLevel(logging.INFO)
    
    return logger

================
File: entry_point.py
================
from .cli import main

if __name__ == "__main__":
    main()

================
File: factories.py
================
from typing import Dict, Any
import logging

from .interfaces import FileSystem, FileParser, DiagramGenerator
from .interfaces import ParserFactory, GeneratorFactory
from .parsers.python_parser import PythonAstParser
from .generators.plantuml_generator import PlantUmlGenerator


class DefaultParserFactory(ParserFactory):
    """Default implementation of ParserFactory."""
    
    def __init__(self, file_system: FileSystem):
        self.file_system = file_system
        self.logger = logging.getLogger(__name__)
        self._parsers = {}
    
    def create_parser(self, file_extension: str) -> FileParser:
        """Create parser for given file extension."""
        if file_extension not in self._parsers:
            if file_extension == ".py":
                self._parsers[file_extension] = PythonAstParser(self.file_system)
            else:
                self.logger.warning(f"No parser available for extension: {file_extension}")
                raise ValueError(f"Unsupported file extension: {file_extension}")
        
        return self._parsers[file_extension]


class DefaultGeneratorFactory(GeneratorFactory):
    """Default implementation of GeneratorFactory."""
    
    def __init__(self, file_system: FileSystem, settings: Dict[str, Any] = None):
        self.file_system = file_system
        self.settings = settings or {}
        self.logger = logging.getLogger(__name__)
        self._generators = {}
    
    def create_generator(self, output_format: str) -> DiagramGenerator:
        """Create generator for given output format."""
        if output_format not in self._generators:
            if output_format == "plantuml":
                self._generators[output_format] = PlantUmlGenerator(
                    self.file_system, self.settings
                )
            else:
                self.logger.warning(f"No generator available for format: {output_format}")
                raise ValueError(f"Unsupported output format: {output_format}")
        
        return self._generators[output_format]

================
File: filesystem.py
================
import os
from pathlib import Path
from typing import List

from .interfaces import FileSystem


class DefaultFileSystem(FileSystem):
    """Default implementation of FileSystem interface."""
    
    def read_file(self, path: Path) -> str:
        """Read file content as string."""
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    
    def write_file(self, path: Path, content: str) -> None:
        """Write content to file."""
        with open(path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def ensure_directory(self, path: Path) -> None:
        """Ensure directory exists, create if needed."""
        path.mkdir(parents=True, exist_ok=True)
    
    def find_files(self, directory: Path, pattern: str) -> List[Path]:
        """Find files matching pattern in directory."""
        return list(directory.glob(pattern))

================
File: generator/plantuml-generator.py
================
from typing import Dict, Any, List, Set
from pathlib import Path
import logging

from ..interfaces import FileSystem, DiagramGenerator
from ..models import FileModel


class PlantUmlGenerator(DiagramGenerator):
    """Generator for PlantUML diagrams."""
    
    def __init__(
        self,
        file_system: FileSystem,
        settings: Dict[str, Any] = None
    ):
        self.file_system = file_system
        self.settings = settings or {}
        self.logger = logging.getLogger(__name__)
        
        # Configure PlantUML settings
        self.plantuml_start = self.settings.get('PLANTUML_START', "@startuml")
        self.plantuml_end = self.settings.get('PLANTUML_END', "@enduml")
        self.plantuml_settings = self.settings.get('PLANTUML_SETTINGS', [
            "skinparam classAttributeIconSize 0",
        ])
        self.show_imports = self.settings.get('show_imports', False)
    
    def get_output_extension(self) -> str:
        """Return output file extension for this generator."""
        return ".puml"
    
    def generate_diagram(self, file_model: FileModel, output_path: Path) -> None:
        """Generate a PlantUML diagram from a FileModel."""
        self.logger.info(f"Generating UML diagram for {file_model.filename}")
        
        uml_content = self._generate_plantuml(file_model)
        
        # Ensure output directory exists
        self.file_system.ensure_directory(output_path.parent)
        
        # Write PlantUML content to file
        self.file_system.write_file(output_path, uml_content)
        
        self.logger.info(
            f"Generated UML diagram at {output_path}",
            extra={
                'class_count': len(file_model.classes),
                'function_count': len(file_model.functions),
            }
        )
    
    def _generate_plantuml(self, file_model: FileModel) -> str:
        """Generate PlantUML code from a FileModel."""
        uml_lines = [self.plantuml_start, *self.plantuml_settings]
        
        # Create a package for the file
        uml_lines.append(f'\npackage "{file_model.filename}" {{')
        
        # Add functions to the package if any
        if file_model.functions:
            uml_lines.append("  class Functions <<(F,orange)>> {")
            for function in file_model.functions:
                visibility = function.visibility
                signature = function.signature
                uml_lines.append(f"    {visibility} {signature}")
            uml_lines.append("  }")
        
        # Add classes to the package
        for class_model in file_model.classes:
            uml_lines.append(f"  class {class_model.name} {{")
            
            # Handle attributes
            for attr in class_model.attributes:
                uml_lines.append(f"    {attr.visibility} {attr.name}: {attr.type_annotation}")
            
            # Handle methods
            for method in class_model.methods:
                uml_lines.append(f"    {method.visibility}{method.signature}")
            
            uml_lines.append("  }")
        
        # Close the package
        uml_lines.append("}")
        
        # Add imports section if show_imports is True
        if self.show_imports:
            uml_lines.append("\n' Imports")
            for class_model in file_model.classes:
                qualified_name = f'"{file_model.filename}".{class_model.name}'
                
                # Add import relationships
                for imp in file_model.imports:
                    # Skip built-ins and standard library modules
                    if not imp.module.startswith(
                        ("typing", "collections", "datetime", "builtins"),
                    ):
                        # Classes (start with uppercase)
                        if imp.name[0].isupper():
                            uml_lines.append(
                                f"note right of {qualified_name}: imports class {imp.name} from {imp.module}",
                            )
                        # Functions and types (don't start with underscore)
                        elif not imp.name.startswith("_"):
                            uml_lines.append(
                                f"note right of {qualified_name}: imports function/type {imp.name} from {imp.module}",
                            )
        
        # Add relationships
        uml_lines.append("\n' Relationships")
        for class_model in file_model.classes:
            qualified_name = f'"{file_model.filename}".{class_model.name}'
            
            # Add inheritance lines
            for base in class_model.bases:
                uml_lines.append(f"{base} <|-- {qualified_name}")
            
            # Add other relationships
            for rel in class_model.relationships:
                uml_lines.append(f"{rel.source} {rel.type} {rel.target}")
        
        uml_lines.append(self.plantuml_end)
        return "\n".join(uml_lines)
    
    def generate_index(self, output_dir: Path, diagrams: List[Path]) -> None:
        """Generate an index.rst file for the generated UML diagrams."""
        output_path = output_dir / "index.rst"
        
        content = [
            "UML Class Diagrams",
            "==================",
            "",
            ".. toctree::",
            "   :maxdepth: 1",
            "",
        ]
        
        for diagram_path in sorted(diagrams):
            name = diagram_path.stem
            content.extend([
                f"{name}",
                f"{'-' * len(name)}",
                "",
                f".. uml:: {diagram_path.name}",
                "   :align: center",
                "",
            ])
        
        self.file_system.write_file(output_path, "\n".join(content))
        self.logger.info(f"Generated UML index at {output_path}")

================
File: interfaces.py
================
from abc import ABC, abstractmethod
from typing import List, Set, Dict, Any, Protocol
from pathlib import Path

from .models import FileModel


class FileSystem(Protocol):
    """Interface for file system operations."""
    
    def read_file(self, path: Path) -> str:
        """Read file content as string."""
        ...
        
    def write_file(self, path: Path, content: str) -> None:
        """Write content to file."""
        ...
        
    def ensure_directory(self, path: Path) -> None:
        """Ensure directory exists, create if needed."""
        ...
        
    def find_files(self, directory: Path, pattern: str) -> List[Path]:
        """Find files matching pattern in directory."""
        ...


class FileParser(ABC):
    """Abstract base class for file parsers."""
    
    @abstractmethod
    def parse_file(self, file_path: Path) -> FileModel:
        """Parse file and return model representation."""
        pass
    
    @abstractmethod
    def get_supported_extensions(self) -> Set[str]:
        """Return set of supported file extensions."""
        pass


class DiagramGenerator(ABC):
    """Abstract base class for diagram generators."""
    
    @abstractmethod
    def generate_diagram(self, file_model: FileModel, output_path: Path) -> None:
        """Generate diagram from file model and write to output path."""
        pass
    
    @abstractmethod
    def get_output_extension(self) -> str:
        """Return output file extension for this generator."""
        pass


class ParserFactory(ABC):
    """Factory for creating appropriate parser based on file extension."""
    
    @abstractmethod
    def create_parser(self, file_extension: str) -> FileParser:
        """Create parser for given file extension."""
        pass


class GeneratorFactory(ABC):
    """Factory for creating diagram generators."""
    
    @abstractmethod
    def create_generator(self, output_format: str) -> DiagramGenerator:
        """Create generator for given output format."""
        pass

================
File: models.py
================
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from pathlib import Path

@dataclass
class Parameter:
    """Function/method parameter representation."""
    name: str
    type_annotation: str
    default_value: Optional[str] = None

@dataclass
class Attribute:
    """Class attribute representation."""
    name: str
    type_annotation: str
    visibility: str = "+"  # +: public, -: private, #: protected

@dataclass
class Method:
    """Method representation with signature information."""
    name: str
    parameters: List[Parameter]
    return_type: str
    visibility: str = "+"  # +: public, -: private, #: protected
    
    @property
    def signature(self) -> str:
        """Generate method signature string."""
        params = [
            f"{param.name}: {param.type_annotation}" +
            (f" = {param.default_value}" if param.default_value else "")
            for param in self.parameters
        ]
        return f"{self.name}({', '.join(params)}) -> {self.return_type}"

@dataclass
class Relationship:
    """Relationship between classes."""
    source: str
    target: str
    type: str  # -->: association, *-->: composition, etc.

@dataclass
class Import:
    """Import statement representation."""
    module: str
    name: str
    alias: Optional[str] = None

@dataclass
class ClassModel:
    """Class representation with methods, attributes and relationships."""
    name: str
    filename: str
    bases: List[str] = field(default_factory=list)
    methods: List[Method] = field(default_factory=list)
    attributes: List[Attribute] = field(default_factory=list)
    relationships: List[Relationship] = field(default_factory=list)
    imports: List[Import] = field(default_factory=list)

@dataclass
class FunctionModel:
    """Standalone function representation."""
    name: str
    parameters: List[Parameter]
    return_type: str
    visibility: str = "+"
    
    @property
    def signature(self) -> str:
        """Generate function signature string."""
        params = [
            f"{param.name}: {param.type_annotation}" +
            (f" = {param.default_value}" if param.default_value else "")
            for param in self.parameters
        ]
        return f"{self.name}({', '.join(params)}) -> {self.return_type}"

@dataclass
class FileModel:
    """File representation containing classes and functions."""
    path: Path
    classes: List[ClassModel] = field(default_factory=list)
    functions: List[FunctionModel] = field(default_factory=list)
    imports: List[Import] = field(default_factory=list)
    
    @property
    def filename(self) -> str:
        """Get filename without extension."""
        return self.path.stem

================
File: parsers/python_parser.py
================
import ast
from typing import List, Set, Tuple, Optional, Dict, Any
from pathlib import Path
import logging

from ..interfaces import FileSystem, FileParser
from ..models import (
    FileModel, ClassModel, FunctionModel, Method,
    Attribute, Parameter, Relationship, Import
)


class PythonAstParser(FileParser):
    """Parser for Python files using the ast module."""
    
    def __init__(self, file_system: FileSystem):
        self.file_system = file_system
        self.logger = logging.getLogger(__name__)
    
    def get_supported_extensions(self) -> Set[str]:
        """Return set of supported file extensions."""
        return {".py"}
    
    def parse_file(self, file_path: Path) -> FileModel:
        """Parse Python file using AST and return a FileModel."""
        self.logger.info(f"Parsing file: {file_path.name}")
        
        content = self.file_system.read_file(file_path)
        tree = ast.parse(content, filename=str(file_path))
        
        imports = self._parse_imports(tree)
        class_names = {
            node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)
        }
        
        # Parse classes
        classes = []
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                classes.append(self._parse_class(node, class_names))
        
        # Parse standalone functions
        functions = []
        for node in ast.walk(tree):
            if (
                isinstance(node, ast.FunctionDef)
                and not hasattr(node, "parent")
                and not any(
                    isinstance(parent, ast.ClassDef)
                    for parent in ast.iter_child_nodes(tree)
                    if hasattr(node, "parent_node") and node.parent_node == parent
                )
            ):
                functions.append(self._parse_function(node))
        
        return FileModel(
            path=file_path,
            classes=classes,
            functions=functions,
            imports=imports
        )
    
    def _parse_imports(self, tree: ast.AST) -> List[Import]:
        """Parse imports from an AST tree."""
        imports = []
        
        for node in ast.walk(tree):
            # Handle 'import module' statements
            if isinstance(node, ast.Import):
                for name in node.names:
                    imports.append(Import(
                        module=name.name,
                        name=name.name.split('.')[-1],
                        alias=name.asname
                    ))
            
            # Handle 'from module import name' statements
            elif isinstance(node, ast.ImportFrom):
                module = node.module or ""
                for name in node.names:
                    imports.append(Import(
                        module=f"{module}.{name.name}",
                        name=name.name,
                        alias=name.asname
                    ))
        
        return imports
    
    def _get_annotation(self, node: Optional[ast.AST]) -> str:
        """Extract type annotation from AST node."""
        if node is None:
            return "Any"
        
        if isinstance(node, ast.Name):
            return node.id
        if isinstance(node, ast.Constant):
            return str(node.value)
        if isinstance(node, ast.Subscript):
            return ast.unparse(node)
        if isinstance(node, ast.BinOp):
            return ast.unparse(node)
        
        return ast.unparse(node)
    
    def _parse_parameters(self, args: ast.arguments, is_method: bool = False) -> List[Parameter]:
        """Parse function parameters from AST arguments."""
        parameters = []
        
        # Skip 'self' parameter for instance methods
        arg_start = 1 if is_method and args.args and args.args[0].arg == "self" else 0
        args_to_process = args.args[arg_start:]
        
        # Process parameters
        for arg in args_to_process:
            param_type = self._get_annotation(arg.annotation)
            parameters.append(Parameter(
                name=arg.arg,
                type_annotation=param_type
            ))
        
        # Handle default values
        defaults = [None] * (len(args_to_process) - len(args.defaults)) + args.defaults
        for i, default in enumerate(defaults):
            if default:
                parameters[i].default_value = ast.unparse(default)
        
        # Handle *args
        if args.vararg:
            vararg_type = self._get_annotation(args.vararg.annotation)
            parameters.append(Parameter(
                name=f"*{args.vararg.arg}",
                type_annotation=vararg_type
            ))
        
        # Handle **kwargs
        if args.kwarg:
            kwarg_type = self._get_annotation(args.kwarg.annotation)
            parameters.append(Parameter(
                name=f"**{args.kwarg.arg}",
                type_annotation=kwarg_type
            ))
        
        return parameters
    
    def _get_method_visibility(self, method_name: str) -> str:
        """Determine method visibility based on name."""
        if method_name.startswith("__") and method_name.endswith("__"):
            return ""  # Special methods remain as is
        if method_name.startswith("__"):
            return "-"  # Private methods
        if method_name.startswith("_"):
            return "#"  # Protected methods
        return "+"  # Public methods
    
    def _parse_function(self, node: ast.FunctionDef) -> FunctionModel:
        """Parse a function definition from AST."""
        name = node.name
        parameters = self._parse_parameters(node.args)
        return_type = self._get_annotation(node.returns)
        visibility = self._get_method_visibility(name)
        
        return FunctionModel(
            name=name,
            parameters=parameters,
            return_type=return_type,
            visibility=visibility
        )
    
    def _find_class_relationships(
        self,
        annotation: ast.AST,
        known_classes: Set[str],
    ) -> List[Tuple[str, str]]:
        """Find relationships to other classes in type annotations."""
        relationships = []
        
        if isinstance(annotation, ast.Name) and annotation.id in known_classes:
            relationships.append(("-->", annotation.id))  # Basic association
        elif isinstance(annotation, ast.Subscript):
            # Handle List[Class], Optional[Class], etc.
            value = annotation.value
            if isinstance(value, ast.Name):
                collection_type = value.id
                if collection_type in ("List", "Sequence", "Collection"):
                    # For collections, use composition with multiplicity
                    if (
                        isinstance(annotation.slice, ast.Name)
                        and annotation.slice.id in known_classes
                    ):
                        relationships.append(("*-->", annotation.slice.id))
                elif collection_type == "Optional" and isinstance(
                    annotation.slice,
                    ast.Name,
                ):
                    if annotation.slice.id in known_classes:
                        relationships.append(("-->", annotation.slice.id))
        
        return relationships
    
    def _parse_class(self, node: ast.ClassDef, known_classes: Set[str]) -> ClassModel:
        """Parse a class definition from AST."""
        class_name = node.name
        bases = [base.id for base in node.bases if isinstance(base, ast.Name)]
        methods = []
        attributes = []
        relationships = []
        
        for class_body_item in node.body:
            # Class methods
            if isinstance(class_body_item, ast.FunctionDef):
                method_name = class_body_item.name
                method_params = self._parse_parameters(class_body_item.args, is_method=True)
                return_type = self._get_annotation(class_body_item.returns)
                visibility = self._get_method_visibility(method_name)
                
                methods.append(Method(
                    name=method_name,
                    parameters=method_params,
                    return_type=return_type,
                    visibility=visibility
                ))
            
            # Class attributes (simple assignments like "x = 10")
            elif isinstance(class_body_item, ast.Assign):
                for target in class_body_item.targets:
                    if isinstance(target, ast.Name):
                        attr_name = target.id
                        visibility = "-" if attr_name.startswith("_") else "+"
                        attributes.append(Attribute(
                            name=attr_name,
                            type_annotation="Any",
                            visibility=visibility
                        ))
            
            # Attributes with type annotations
            elif isinstance(class_body_item, ast.AnnAssign):
                if isinstance(class_body_item.target, ast.Name):
                    attr_name = class_body_item.target.id
                    attr_type = self._get_annotation(class_body_item.annotation)
                    visibility = "-" if attr_name.startswith("_") else "+"
                    attributes.append(Attribute(
                        name=attr_name,
                        type_annotation=attr_type,
                        visibility=visibility
                    ))
                    
                    # Check for relationships in type annotations
                    new_relationships = self._find_class_relationships(
                        class_body_item.annotation,
                        known_classes,
                    )
                    for rel_type, target in new_relationships:
                        relationships.append(Relationship(
                            source=class_name,
                            target=target,
                            type=rel_type
                        ))
        
        return ClassModel(
            name=class_name,
            filename=node.name,
            bases=bases,
            methods=methods,
            attributes=attributes,
            relationships=relationships
        )

================
File: service.py
================
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional

from .interfaces import FileSystem, ParserFactory, GeneratorFactory
from .config import Configuration


class UmlGeneratorService:
    """Service for generating UML diagrams from source code."""
    
    def __init__(
        self,
        config: Configuration,
        file_system: FileSystem,
        parser_factory: ParserFactory,
        generator_factory: GeneratorFactory,
        logger: Optional[logging.Logger] = None
    ):
        self.config = config
        self.file_system = file_system
        self.parser_factory = parser_factory
        self.generator_factory = generator_factory
        self.logger = logger or logging.getLogger(__name__)
    
    def process_file(self, file_path: Path) -> bool:
        """Process a single file and generate UML diagram.
        
        Returns True if processing was successful, False otherwise.
        """
        self.logger.info(f"Processing file: {file_path}")
        
        try:
            # Skip if this is just a listing operation
            if self.config.list_only:
                self.logger.info(f"Listing file: {file_path}")
                return True
            
            # Skip files with unsupported extensions
            if file_path.suffix != self.config.input_extension:
                self.logger.warning(f"Skipping unsupported file type: {file_path}")
                return False
            
            # Get appropriate parser
            parser = self.parser_factory.create_parser(file_path.suffix)
            
            # Parse the file
            file_model = parser.parse_file(file_path)
            
            if not file_model.classes and not file_model.functions:
                self.logger.warning(f"No classes or functions found in file: {file_path}")
                return False
            
            # Get appropriate generator
            generator = self.generator_factory.create_generator(self.config.output_format)
            
            # Generate the UML diagram
            output_extension = generator.get_output_extension()
            output_path = self.config.output_dir / f"{file_path.stem}{output_extension}"
            generator.generate_diagram(file_model, output_path)
            
            self.logger.info(
                f"Generated UML diagram for {file_path.stem}",
                extra={
                    'output_path': str(output_path),
                    'class_count': len(file_model.classes),
                    'function_count': len(file_model.functions),
                }
            )
            return True
        
        except Exception as e:
            self.logger.exception(
                f"Error processing file {file_path}",
                exc_info=e,
            )
            return False
    
    def process_directory(self, directory: Path) -> int:
        """Process all files in a directory.
        
        Returns the number of successfully processed files.
        """
        self.logger.info(f"Processing directory: {directory}")
        
        # Find all files with the configured extension in the directory
        files = self.file_system.find_files(
            directory, f"*{self.config.input_extension}"
        )
        
        if not files:
            self.logger.warning(f"No files with extension {self.config.input_extension} found in {directory}")
            return 0
        
        # Log the files found
        self.logger.info(f"Found {len(files)} files in {directory}")
        
        # Process each file
        success_count = 0
        for file_path in files:
            if self.process_file(file_path):
                success_count += 1
        
        # Process subdirectories if recursive flag is set
        if self.config.recursive:
            for subdir in directory.iterdir():
                if subdir.is_dir():
                    success_count += self.process_directory(subdir)
        
        return success_count
    
    def run(self) -> None:
        """Run the UML generator service."""
        self.logger.info(
            "Starting UML generation",
            extra={
                'source_dir': str(self.config.source_dir),
                'output_dir': str(self.config.output_dir),
            }
        )
        
        # Ensure output directory exists
        self.file_system.ensure_directory(self.config.output_dir)
        
        # Process single file if specified
        if self.config.single_file:
            if not self.config.single_file.exists():
                self.logger.error(f"File does not exist: {self.config.single_file}")
                return
            
            self.process_file(self.config.single_file)
            return
        
        # Process the main directory
        total_processed = self.process_directory(self.config.source_dir)
        
        # Process subdirectories if specified
        if self.config.subdirs and not self.config.recursive:
            for subdir_name in self.config.subdirs:
                subdir = self.config.source_dir / subdir_name
                if subdir.exists() and subdir.is_dir():
                    total_processed += self.process_directory(subdir)
                else:
                    self.logger.warning(f"Subdirectory not found: {subdir}")
        
        # Generate index.rst for Sphinx integration if using PlantUML
        generator = self.generator_factory.create_generator(self.config.output_format)
        if hasattr(generator, 'generate_index'):
            output_extension = generator.get_output_extension()
            diagrams = self.file_system.find_files(
                self.config.output_dir, f"*{output_extension}"
            )
            generator.generate_index(self.config.output_dir, diagrams)
        
        self.logger.info(f"UML generation completed - processed {total_processed} files")



================================================================
End of Codebase
================================================================
