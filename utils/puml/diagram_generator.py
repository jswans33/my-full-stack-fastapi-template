"""
PlantUML diagram generation.

This module handles the generation of PlantUML diagrams from analyzed code structure.
"""

from pathlib import Path

from utils.puml.core import ensure_dir_exists, setup_logger
from utils.puml.exceptions import DiagramGenerationError
from utils.puml.models import Module

# Set up logger
logger = setup_logger("diagram_generator")


def _add_classes_to_diagram(module: Module, diagram: list[str]) -> None:
    """Add class definitions to the diagram."""
    for class_obj in module.classes.values():
        # Start class definition
        diagram.append(
            f'class "{class_obj.name}" as {class_obj.full_name.replace(".", "_")} {{',
        )

        # Add attributes
        for attr in class_obj.attributes.values():
            attr_type = attr.get("type", "")
            if attr_type:
                diagram.append(f"  {attr['name']}: {attr_type}")
            else:
                diagram.append(f"  {attr['name']}")

        # Add methods
        for method in class_obj.methods.values():
            args_str = ", ".join(method.args)
            return_type = f": {method.return_type}" if method.return_type else ""
            diagram.append(f"  +{method.name}({args_str}){return_type}")

        # End class definition
        diagram.append("}")
        diagram.append("")


def _add_functions_to_diagram(module: Module, diagram: list[str]) -> None:
    """Add standalone functions to the diagram."""
    for func in module.functions.values():
        # Add function as a class with stereotype
        diagram.append(
            f'class "{func.name}" as {func.full_name.replace(".", "_")} <<function>> {{',
        )
        args_str = ", ".join(func.args)
        return_type = f": {func.return_type}" if func.return_type else ""
        diagram.append(f"  +{func.name}({args_str}){return_type}")
        diagram.append("}")
        diagram.append("")


def _add_relationships_to_diagram(modules: list[Module], diagram: list[str]) -> None:
    """Add relationships between classes and functions to the diagram."""
    relationships_added = set()

    for module in modules:
        # Add class inheritance relationships
        for class_obj in module.classes.values():
            for source, target, rel_type in class_obj.relationships:
                if rel_type == "inherits":
                    rel_key = f"{source}_{target}_inherits"
                    if rel_key not in relationships_added:
                        diagram.append(
                            f"{source.replace('.', '_')} --|> {target.replace('.', '_')}",
                        )
                        relationships_added.add(rel_key)

        # Add method call relationships
        for class_obj in module.classes.values():
            for method in class_obj.methods.values():
                for called in method.calls:
                    rel_key = f"{method.full_name}_{called}_calls"
                    if rel_key not in relationships_added:
                        diagram.append(
                            f"{method.full_name.replace('.', '_')} ..> {called.replace('.', '_')} : calls",
                        )
                        relationships_added.add(rel_key)

        # Add function call relationships
        for func in module.functions.values():
            for called in func.calls:
                rel_key = f"{func.full_name}_{called}_calls"
                if rel_key not in relationships_added:
                    diagram.append(
                        f"{func.full_name.replace('.', '_')} ..> {called.replace('.', '_')} : calls",
                    )
                    relationships_added.add(rel_key)


def generate_class_diagram(
    modules: list[Module], include_functions: bool = False
) -> str:
    """
    Generate a PlantUML class diagram from analyzed code.

    Args:
        modules: List of Module objects containing analyzed code structure
        include_functions: Whether to include standalone functions in the diagram

    Returns:
        PlantUML diagram as a string

    Raises:
        DiagramGenerationError: If there is an error generating the diagram
    """
    try:
        logger.info("Generating class diagram")

        # Start the diagram
        diagram = [
            '@startuml "Code Analysis Class Diagram"',
            "",
            "' This diagram was automatically generated by the code analyzer",
            "",
        ]

        # Add classes from all modules
        for module in modules:
            _add_classes_to_diagram(module, diagram)

        # Add functions if requested
        if include_functions:
            for module in modules:
                _add_functions_to_diagram(module, diagram)

        # Add relationships
        _add_relationships_to_diagram(modules, diagram)

        # End the diagram
        diagram.append("")
        diagram.append("@enduml")

        return "\n".join(diagram)
    except Exception as e:
        raise DiagramGenerationError(f"Error generating class diagram: {e}")


def generate_module_diagram(modules: list[Module]) -> str:
    """
    Generate a PlantUML component diagram showing module dependencies.

    Args:
        modules: List of Module objects containing analyzed code structure

    Returns:
        PlantUML diagram as a string

    Raises:
        DiagramGenerationError: If there is an error generating the diagram
    """
    try:
        logger.info("Generating module diagram")

        # Start the diagram
        diagram = [
            '@startuml "Code Analysis Module Diagram"',
            "",
            "' This diagram was automatically generated by the code analyzer",
            "",
        ]

        # Add all modules as components
        module_names = {module.name for module in modules}
        for module in modules:
            diagram.append(f"[{module.name}] as {module.name.replace('.', '_')}")

        diagram.append("")

        # Add dependencies between modules
        dependencies_added = set()
        for module in modules:
            for imported_name in module.imports.values():
                # Get the top-level module name
                top_module = imported_name.split(".")[0]
                if top_module in module_names and top_module != module.name:
                    dep_key = f"{module.name}_{top_module}"
                    if dep_key not in dependencies_added:
                        diagram.append(
                            f"{module.name.replace('.', '_')} --> {top_module.replace('.', '_')}",
                        )
                        dependencies_added.add(dep_key)

        # End the diagram
        diagram.append("")
        diagram.append("@enduml")

        return "\n".join(diagram)
    except Exception as e:
        raise DiagramGenerationError(f"Error generating module diagram: {e}")


def save_diagram(diagram: str, output_file: str | Path) -> None:
    """
    Save a PlantUML diagram to a file.

    Args:
        diagram: PlantUML diagram as a string
        output_file: Path to save the diagram to

    Raises:
        DiagramGenerationError: If there is an error saving the diagram
    """
    try:
        path = Path(output_file)
        ensure_dir_exists(path.parent)
        path.write_text(diagram, encoding="utf-8")
        logger.info(f"Saved diagram to {path}")
    except Exception as e:
        raise DiagramGenerationError(f"Error saving diagram to {output_file}: {e}")


if __name__ == "__main__":
    import sys

    from utils.puml.analyzer import analyze_file

    if len(sys.argv) > 1:
        module = analyze_file(sys.argv[1])
        diagram = generate_class_diagram([module])
        print(diagram)
