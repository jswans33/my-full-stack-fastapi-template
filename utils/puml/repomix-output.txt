This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
__init__.py
api.py
cli.py
code_analyzer.py
config.py
core.py
docs/plantuml-utilities.md
docs/README.md
exceptions.py
Makefile
render_diagrams.py
settings.py
tests/__init__.py
tests/test_code_analyzer.py
tests/test_puml.py
viewer/index.html

================================================================
Files
================================================================

================
File: __init__.py
================
"""
PlantUML Utilities Package

This package provides utilities for working with PlantUML diagrams in the project.

Features:
- Render PlantUML diagrams to PNG or SVG images
- View rendered diagrams in a React-based viewer
- Analyze code and generate PlantUML diagrams automatically
- Command-line interface for rendering, viewing, and analyzing code
"""

import os
import sys

# Add the parent directory to sys.path to allow imports to work
# regardless of where the code is executed from
package_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(os.path.dirname(package_dir))
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

# Try to import using relative imports first, then fall back to absolute imports
try:
    # Import the main functions for the public API
    from .code_analyzer import (
        analyze_and_generate_diagram,
        analyze_directory,
        analyze_file,
        generate_class_diagram,
        generate_module_diagram,
        save_diagram,
    )
    from .config import (
        DEFAULT_FORMAT,
        FORMATS,
        OUTPUT_DIR,
        SOURCE_DIR,
    )
    from .core import ensure_dir_exists, setup_logger
    from .render_diagrams import (
        launch_viewer,
        render_all_diagrams,
        render_diagram,
    )
except (ImportError, ValueError):
    # Fall back to absolute imports
    from utils.puml.code_analyzer import (
        analyze_and_generate_diagram,
        analyze_directory,
        analyze_file,
        generate_class_diagram,
        generate_module_diagram,
        save_diagram,
    )
    from utils.puml.config import (
        DEFAULT_FORMAT,
        FORMATS,
        OUTPUT_DIR,
        SOURCE_DIR,
    )
    from utils.puml.core import ensure_dir_exists, setup_logger
    from utils.puml.render_diagrams import (
        launch_viewer,
        render_all_diagrams,
        render_diagram,
    )

# Define what's available when using "from utils.puml import *"
__all__ = [
    # Rendering functions
    "render_diagram",
    "render_all_diagrams",
    "launch_viewer",
    # Code analysis functions
    "analyze_file",
    "analyze_directory",
    "analyze_and_generate_diagram",
    "generate_class_diagram",
    "generate_module_diagram",
    "save_diagram",
    # Configuration
    "SOURCE_DIR",
    "OUTPUT_DIR",
    "DEFAULT_FORMAT",
    "FORMATS",
    # Utilities
    "setup_logger",
    "ensure_dir_exists",
]

================
File: api.py
================
import os

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

app = FastAPI()

# Allow CORS for React development server
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Convert relative path to absolute path
diagrams_dir = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "../../docs/diagrams/output")
)


@app.get("/api/diagrams")
def get_diagrams():
    diagram_structure = {}
    for root, _, files in os.walk(diagrams_dir):
        rel_dir = os.path.relpath(root, diagrams_dir)
        # Group files by base name (without extension)
        diagram_files = {}
        for f in files:
            if f.endswith((".svg", ".png")):
                base_name = os.path.splitext(f)[0]
                diagram_files[base_name] = True

        if diagram_files:
            if rel_dir == ".":
                rel_dir = "root"
            diagram_structure[rel_dir] = list(diagram_files.keys())
    return diagram_structure


# Serve diagrams statically
# Convert relative path to absolute path
diagrams_dir = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "../../docs/diagrams/output"),
)

app.mount(
    "/diagrams",
    StaticFiles(directory=diagrams_dir),
    name="diagrams",
)

================
File: cli.py
================
#!/usr/bin/env python
"""
PlantUML Command Line Interface

This script provides a command-line interface for working with PlantUML diagrams.

Usage:
    python -m utils.puml.cli render [--format=<format>] [--source=<source_dir>] [--output=<output_dir>] [--file=<file>]
    python -m utils.puml.cli view
    python -m utils.puml.cli analyze [--path=<path>] [--output=<output_file>] [--modules] [--functions] [--verbose]
    python -m utils.puml.cli help
"""

import argparse
import sys
from collections.abc import Sequence
from pathlib import Path

from .code_analyzer import analyze_and_generate_diagram
from .core import setup_logger
from .exceptions import (
    AnalyzerError,
    PlantUMLError,
    RenderError,
)
from .render_diagrams import launch_viewer, render_all_diagrams, render_diagram
from .settings import settings

# Set up logger
logger = setup_logger("cli")


class CommandError(PlantUMLError):
    """Base exception for command-line interface errors."""

    pass


class InvalidCommandError(CommandError):
    """Raised when an invalid command is provided."""

    pass


class CommandArgumentError(CommandError):
    """Raised when invalid command arguments are provided."""

    pass


def show_help() -> None:
    """Show the help message."""
    print(__doc__)


def path_type(value: str) -> Path:
    """Convert string argument to Path object."""
    return Path(value)


def render_command(args: Sequence[str]) -> int:
    """
    Handle the render command.

    Args:
        args: Command-line arguments

    Returns:
        Exit code (0 for success, non-zero for failure)

    Raises:
        CommandArgumentError: If invalid arguments are provided
        RenderError: If there is an error rendering diagrams
    """
    try:
        # Parse arguments
        parser = argparse.ArgumentParser(
            description="Render PlantUML diagrams to images"
        )
        parser.add_argument(
            "--format",
            choices=settings.supported_formats,
            default=settings.default_format,
            help=f"Output format ({' or '.join(settings.supported_formats)})",
        )
        parser.add_argument(
            "--source",
            type=path_type,
            default=settings.source_dir,
            help="Source directory for PlantUML files",
        )
        parser.add_argument(
            "--output",
            type=path_type,
            default=settings.output_dir,
            help="Output directory for rendered images",
        )
        parser.add_argument(
            "--file",
            type=path_type,
            help="Specific .puml file to render",
        )

        # Parse the arguments
        parsed_args = parser.parse_args(args)

        # Render the diagrams
        if parsed_args.file:
            # Render a specific file
            file_path = (
                parsed_args.source / parsed_args.file
                if not parsed_args.file.is_absolute()
                else parsed_args.file
            )
            if not file_path.exists():
                raise CommandArgumentError(f"File not found: {file_path}")

            success = render_diagram(file_path, parsed_args.output, parsed_args.format)
            return 0 if success else 1

        # Render all diagrams
        success_count, total_count = render_all_diagrams(
            parsed_args.source,
            parsed_args.output,
            parsed_args.format,
        )
        return 0 if success_count > 0 else 1

    except (CommandArgumentError, RenderError) as e:
        logger.error(str(e))
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1


def view_command() -> int:
    """
    Handle the view command.

    Returns:
        Exit code (0 for success, non-zero for failure)
    """
    try:
        success = launch_viewer()
        return 0 if success else 1
    except RenderError as e:
        logger.error(str(e))
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1


def analyze_command(args: Sequence[str]) -> int:
    """
    Handle the analyze command.

    Args:
        args: Command-line arguments

    Returns:
        Exit code (0 for success, non-zero for failure)

    Raises:
        CommandArgumentError: If invalid arguments are provided
        AnalyzerError: If there is an error analyzing code
    """
    try:
        # Parse arguments
        parser = argparse.ArgumentParser(
            description="Analyze code and generate PlantUML diagrams",
        )
        parser.add_argument(
            "--path",
            type=path_type,
            default=Path("."),
            help="Path to the Python file or directory to analyze",
        )
        parser.add_argument(
            "--output",
            type=path_type,
            default=None,
            help="Output file for the PlantUML diagram",
        )
        parser.add_argument(
            "--modules",
            action="store_true",
            help="Generate a module diagram instead of a class diagram",
        )
        parser.add_argument(
            "--functions",
            action="store_true",
            help="Include standalone functions in the class diagram",
        )
        parser.add_argument(
            "--verbose",
            action="store_true",
            help="Enable verbose logging",
        )

        # Parse the arguments
        parsed_args = parser.parse_args(args)

        # Set up verbose logging if requested
        if parsed_args.verbose:
            setup_logger("code_analyzer", verbose=True)
            setup_logger("cli", verbose=True)

        # Analyze the code and generate the diagram
        output_file = analyze_and_generate_diagram(
            path=parsed_args.path,
            output=parsed_args.output,
            modules=parsed_args.modules,
            functions=parsed_args.functions,
        )

        logger.info(f"\nGenerated diagram: {output_file}")
        logger.info(
            "You can render it using: python -m utils.puml.cli render --file="
            + f"code_analysis/{output_file.name}",
        )
        return 0

    except AnalyzerError as e:
        logger.error(str(e))
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1


def main() -> int:
    """
    Main function.

    Returns:
        Exit code (0 for success, non-zero for failure)
    """
    try:
        # Parse command-line arguments
        if len(sys.argv) < 2:
            show_help()
            return 1

        command = sys.argv[1].lower()
        args = sys.argv[2:]

        # Handle commands
        if command == "render":
            return render_command(args)
        if command == "view":
            return view_command()
        if command == "analyze":
            return analyze_command(args)
        if command == "help":
            show_help()
            return 0

        raise InvalidCommandError(f"Unknown command: {command}")

    except InvalidCommandError as e:
        logger.error(str(e))
        show_help()
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())

================
File: code_analyzer.py
================
"""
Code Analyzer for PlantUML

This module analyzes Python code and generates PlantUML diagrams based on the code structure.
It extracts classes, functions, and relationships between them.
"""

import ast
from pathlib import Path
from typing import TypedDict

from .core import ensure_dir_exists, setup_logger
from .exceptions import (
    AnalyzerError,
    DiagramGenerationError,
    InvalidPathError,
    NoFilesAnalyzedError,
    ParseError,
)
from .settings import settings


# Define a TypedDict for module information
class ModuleInfo(TypedDict):
    imports: set[str]
    classes: list[str]
    functions: list[str]


# Set up logger
logger = setup_logger("code_analyzer")


class CodeVisitor(ast.NodeVisitor):
    """AST visitor that extracts classes, functions, and relationships from Python code."""

    def __init__(self, filename: str | Path, module_name: str):
        self.filename = str(filename)
        self.module_name = module_name
        self.classes: dict[str, dict] = {}
        self.functions: dict[str, dict] = {}
        self.imports: dict[str, str] = {}
        self.relationships: list[tuple[str, str, str]] = []
        self.current_class: str | None = None
        self.current_function: str | None = None
        self.base_classes: dict[str, list[str]] = {}
        self.method_calls: list[tuple[str, str, str]] = []
        logger.info(f"Analyzing file: {filename} (module: {module_name})")

    # Note: We're keeping the method names as-is despite the N802 warnings
    # because these are overriding methods from ast.NodeVisitor and need to match
    # the expected method names for the visitor pattern to work correctly.

    def visit_ClassDef(self, node: ast.ClassDef) -> None:  # noqa: N802
        """Visit a class definition."""
        class_name = f"{self.module_name}.{node.name}"
        logger.debug(f"Found class: {class_name}")

        # Store class information
        self.classes[class_name] = {
            "name": node.name,
            "full_name": class_name,
            "methods": [],
            "attributes": [],
            "docstring": ast.get_docstring(node),
            "lineno": node.lineno,
        }

        # Store base classes
        bases = []
        for base in node.bases:
            if isinstance(base, ast.Name):
                bases.append(base.id)
                self.relationships.append((class_name, base.id, "inherits"))
                logger.debug(f"  Inherits from: {base.id}")
            elif isinstance(base, ast.Attribute):
                base_name = self._get_attribute_name(base)
                bases.append(base_name)
                self.relationships.append((class_name, base_name, "inherits"))
                logger.debug(f"  Inherits from: {base_name}")

        self.base_classes[class_name] = bases

        # Visit class body with this class as the current class
        old_class = self.current_class
        self.current_class = class_name
        for item in node.body:
            self.visit(item)
        self.current_class = old_class

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:  # noqa: N802
        """Visit a function definition."""
        if self.current_class:
            # This is a method
            method_name = node.name
            full_name = f"{self.current_class}.{method_name}"
            logger.debug(f"Found method: {full_name}")

            # Add to class methods
            self.classes[self.current_class]["methods"].append(
                {
                    "name": method_name,
                    "full_name": full_name,
                    "args": [arg.arg for arg in node.args.args],
                    "docstring": ast.get_docstring(node),
                    "lineno": node.lineno,
                },
            )

            # Check if it's a special method
            if method_name.startswith("__") and method_name.endswith("__"):
                logger.debug(f"  Special method: {method_name}")
        else:
            # This is a standalone function
            function_name = f"{self.module_name}.{node.name}"
            logger.debug(f"Found function: {function_name}")

            self.functions[function_name] = {
                "name": node.name,
                "full_name": function_name,
                "args": [arg.arg for arg in node.args.args],
                "docstring": ast.get_docstring(node),
                "lineno": node.lineno,
            }

        # Visit function body
        old_function = self.current_function
        self.current_function = (
            function_name
            if not self.current_class
            else f"{self.current_class}.{node.name}"
        )
        for item in node.body:
            self.visit(item)
        self.current_function = old_function

    def visit_Assign(self, node: ast.Assign) -> None:  # noqa: N802
        """Visit an assignment."""
        if self.current_class:
            # Check if this is a class attribute assignment
            for target in node.targets:
                if isinstance(target, ast.Name):
                    attr_name = target.id
                    if not attr_name.startswith("_") or attr_name.startswith("__"):
                        logger.debug(f"  Found attribute: {attr_name}")
                        self.classes[self.current_class]["attributes"].append(
                            {
                                "name": attr_name,
                                "lineno": node.lineno,
                            },
                        )

        # Continue visiting
        self.generic_visit(node)

    def visit_AnnAssign(self, node: ast.AnnAssign) -> None:  # noqa: N802
        """Visit an annotated assignment."""
        if self.current_class and isinstance(node.target, ast.Name):
            attr_name = node.target.id
            if not attr_name.startswith("_") or attr_name.startswith("__"):
                logger.debug(f"  Found annotated attribute: {attr_name}")

                # Get the type annotation if possible
                type_annotation = ""
                if isinstance(node.annotation, ast.Name):
                    type_annotation = node.annotation.id
                elif isinstance(node.annotation, ast.Subscript) and isinstance(
                    node.annotation.value, ast.Name
                ):
                    type_annotation = node.annotation.value.id

                self.classes[self.current_class]["attributes"].append(
                    {
                        "name": attr_name,
                        "type": type_annotation,
                        "lineno": node.lineno,
                    },
                )

        # Continue visiting
        self.generic_visit(node)

    def visit_Import(self, node: ast.Import) -> None:  # noqa: N802
        """Visit an import statement."""
        for name in node.names:
            self.imports[name.asname or name.name] = name.name
            logger.debug(f"Import: {name.name} as {name.asname or name.name}")

        # Continue visiting
        self.generic_visit(node)

    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:  # noqa: N802
        """Visit an import from statement."""
        if node.module:
            for name in node.names:
                imported_name = name.name
                as_name = name.asname or imported_name
                full_name = f"{node.module}.{imported_name}"
                self.imports[as_name] = full_name
                logger.debug(f"ImportFrom: {full_name} as {as_name}")

        # Continue visiting
        self.generic_visit(node)

    def visit_Call(self, node: ast.Call) -> None:  # noqa: N802
        """Visit a function call."""
        if isinstance(node.func, ast.Attribute) and isinstance(
            node.func.value, ast.Name
        ):
            # This might be a method call on an object
            obj_name = node.func.value.id
            method_name = node.func.attr

            if self.current_function:
                caller = self.current_function
                called = f"{obj_name}.{method_name}"
                self.method_calls.append((caller, called, "calls"))
                logger.debug(f"Method call: {caller} -> {called}")

        # Continue visiting
        self.generic_visit(node)

    def _get_attribute_name(self, node: ast.Attribute) -> str:
        """Get the full name of an attribute."""
        if isinstance(node.value, ast.Name):
            return f"{node.value.id}.{node.attr}"
        if isinstance(node.value, ast.Attribute):
            return f"{self._get_attribute_name(node.value)}.{node.attr}"
        return node.attr


def analyze_file(file_path: str | Path) -> CodeVisitor | None:
    """
    Analyze a Python file and extract its structure.

    Args:
        file_path: Path to the Python file

    Returns:
        CodeVisitor with the extracted information

    Raises:
        ParseError: If there is an error parsing the file
    """
    path = Path(file_path)
    try:
        source = path.read_text(encoding="utf-8")
        tree = ast.parse(source, filename=str(path))
        module_name = path.stem
        visitor = CodeVisitor(path, module_name)
        visitor.visit(tree)
        return visitor
    except Exception as e:
        raise ParseError(str(path), e)


def analyze_directory(
    directory: str | Path,
    exclude_dirs: list[str] | None = None,
) -> list[CodeVisitor]:
    """
    Analyze all Python files in a directory and its subdirectories.

    Args:
        directory: Directory to analyze
        exclude_dirs: List of directory names to exclude

    Returns:
        List of CodeVisitor objects with the extracted information

    Raises:
        AnalyzerError: If there is an error analyzing the directory
    """
    if exclude_dirs is None:
        exclude_dirs = ["__pycache__", "venv", ".venv", ".git", "node_modules"]

    try:
        path = Path(directory)
        visitors = []
        logger.info(f"Analyzing directory: {path}")

        # Use pathlib's rglob to find all Python files
        for file_path in path.rglob("*.py"):
            # Skip files in excluded directories
            if any(d in file_path.parts for d in exclude_dirs):
                continue

            try:
                visitor = analyze_file(file_path)
                if visitor:
                    visitors.append(visitor)
            except ParseError as e:
                logger.warning(str(e))

        logger.info(f"Analyzed {len(visitors)} Python files")
        return visitors
    except Exception as e:
        raise AnalyzerError(f"Error analyzing directory {directory}: {e}")


def _add_classes_to_diagram(visitors: list[CodeVisitor], diagram: list[str]) -> None:
    """Add class definitions to the diagram."""
    for visitor in visitors:
        for class_name, class_info in visitor.classes.items():
            # Start the class definition
            diagram.append(
                f'class "{class_info["name"]}" as {class_name.replace(".", "_")} {{',
            )

            # Add attributes
            for attr in class_info["attributes"]:
                attr_type = attr.get("type", "")
                if attr_type:
                    diagram.append(f"  {attr['name']}: {attr_type}")
                else:
                    diagram.append(f"  {attr['name']}")

            # Add methods
            for method in class_info["methods"]:
                args_str = ", ".join(method["args"])
                diagram.append(f"  +{method['name']}({args_str})")

            # End the class definition
            diagram.append("}")
            diagram.append("")


def _add_functions_to_diagram(visitors: list[CodeVisitor], diagram: list[str]) -> None:
    """Add standalone functions to the diagram."""
    for visitor in visitors:
        for func_name, func_info in visitor.functions.items():
            # Add the function as a class with a stereotype
            diagram.append(
                f'class "{func_info["name"]}" as {func_name.replace(".", "_")} <<function>> {{',
            )
            args_str = ", ".join(func_info["args"])
            diagram.append(f"  +{func_info['name']}({args_str})")
            diagram.append("}")
            diagram.append("")


def _add_relationships_to_diagram(
    visitors: list[CodeVisitor],
    diagram: list[str],
    include_functions: bool,
) -> None:
    """Add relationships between classes and functions to the diagram."""
    # Add inheritance relationships
    for visitor in visitors:
        for class_name, bases in visitor.base_classes.items():
            for base in bases:
                # Check if the base class is a known class or an import
                base_full = visitor.imports.get(base, base)
                diagram.append(
                    f"{class_name.replace('.', '_')} --|> {base_full.replace('.', '_')}",
                )

    # Add method call relationships (simplified)
    method_calls_added: set[str] = set()
    for visitor in visitors:
        for caller, called, _ in visitor.method_calls:
            # Only add each relationship once and only if both caller and called are known
            rel_key = f"{caller}_{called}"
            if rel_key not in method_calls_added:
                # Check if the called method is in our known classes/methods
                called_parts = called.split(".")
                if (
                    len(called_parts) >= 2
                    and called_parts[0] in visitor.imports
                    and include_functions
                ):
                    # This is a call to an imported module
                    diagram.append(
                        f"{caller.replace('.', '_')} ..> {called.replace('.', '_')} : calls",
                    )
                    method_calls_added.add(rel_key)


def generate_class_diagram(
    visitors: list[CodeVisitor],
    include_functions: bool = False,
) -> str:
    """
    Generate a PlantUML class diagram from the analyzed code.

    Args:
        visitors: List of CodeVisitor objects with the extracted information
        include_functions: Whether to include standalone functions in the diagram

    Returns:
        PlantUML diagram as a string

    Raises:
        DiagramGenerationError: If there is an error generating the diagram
    """
    try:
        logger.info("Generating class diagram")

        # Start the diagram
        diagram = [
            '@startuml "Code Analysis Class Diagram"',
            "",
            "' This diagram was automatically generated by the code analyzer",
            "",
        ]

        # Add classes, functions, and relationships using helper functions
        _add_classes_to_diagram(visitors, diagram)

        if include_functions:
            _add_functions_to_diagram(visitors, diagram)

        _add_relationships_to_diagram(visitors, diagram, include_functions)

        # End the diagram
        diagram.append("")
        diagram.append("@enduml")

        return "\n".join(diagram)
    except Exception as e:
        raise DiagramGenerationError(f"Error generating class diagram: {e}")


def generate_module_diagram(visitors: list[CodeVisitor]) -> str:
    """
    Generate a PlantUML component diagram showing module dependencies.

    Args:
        visitors: List of CodeVisitor objects with the extracted information

    Returns:
        PlantUML diagram as a string

    Raises:
        DiagramGenerationError: If there is an error generating the diagram
    """
    try:
        logger.info("Generating module diagram")

        # Start the diagram
        diagram = [
            '@startuml "Code Analysis Module Diagram"',
            "",
            "' This diagram was automatically generated by the code analyzer",
            "",
        ]

        # Track modules and their imports
        modules: dict[str, ModuleInfo] = {}

        # Add all modules
        for visitor in visitors:
            module_name = visitor.module_name
            if module_name not in modules:
                modules[module_name] = {
                    "imports": set(),
                    "classes": [
                        class_info["name"] for class_info in visitor.classes.values()
                    ],
                    "functions": [
                        func_info["name"] for func_info in visitor.functions.values()
                    ],
                }

            # Add imports
            for _, import_name in visitor.imports.items():
                # Extract the top-level module
                top_module = import_name.split(".")[0]
                if top_module != module_name:  # Don't add self-imports
                    modules[module_name]["imports"].add(top_module)

        # Add components for each module
        for module_name in modules:
            diagram.append(f"[{module_name}] as {module_name.replace('.', '_')}")

        diagram.append("")

        # Add dependencies between modules
        for module_name, module_info in modules.items():
            for imported_module in module_info["imports"]:
                if (
                    imported_module in modules
                ):  # Only add if the imported module is in our analysis
                    diagram.append(
                        f"{module_name.replace('.', '_')} --> {imported_module.replace('.', '_')}",
                    )

        # End the diagram
        diagram.append("")
        diagram.append("@enduml")

        return "\n".join(diagram)
    except Exception as e:
        raise DiagramGenerationError(f"Error generating module diagram: {e}")


def save_diagram(diagram: str, output_file: str | Path) -> None:
    """
    Save a PlantUML diagram to a file.

    Args:
        diagram: PlantUML diagram as a string
        output_file: Path to save the diagram to

    Raises:
        DiagramGenerationError: If there is an error saving the diagram
    """
    try:
        path = Path(output_file)
        ensure_dir_exists(path.parent)
        path.write_text(diagram, encoding="utf-8")
        logger.info(f"Saved diagram to {path}")
    except Exception as e:
        raise DiagramGenerationError(f"Error saving diagram to {output_file}: {e}")


def analyze_and_generate_diagram(
    path: str | Path = ".",
    output: str | Path | None = None,
    modules: bool = False,
    functions: bool = False,
) -> Path:
    """
    Analyze code and generate a PlantUML diagram.

    This is the main entry point for code analysis functionality.

    Args:
        path: Path to the Python file or directory to analyze
        output: Output file for the PlantUML diagram
        modules: Whether to generate a module diagram instead of a class diagram
        functions: Whether to include standalone functions in the class diagram

    Returns:
        Path to the generated diagram file

    Raises:
        InvalidPathError: If the provided path is invalid
        NoFilesAnalyzedError: If no Python files were successfully analyzed
        AnalyzerError: If there is an error during analysis
    """
    try:
        input_path = Path(path)

        # Analyze the code
        if input_path.is_dir():
            logger.info(f"Analyzing directory: {input_path}")
            visitors = analyze_directory(input_path)
        elif input_path.is_file() and input_path.suffix == ".py":
            logger.info(f"Analyzing file: {input_path}")
            visitor = analyze_file(input_path)
            visitors = [visitor] if visitor else []
        else:
            logger.error(f"Invalid path: {input_path}")
            raise InvalidPathError(str(input_path))

        if not visitors:
            logger.error("No Python files were successfully analyzed")
            raise NoFilesAnalyzedError()

        # Generate the diagram
        if modules:
            diagram = generate_module_diagram(visitors)
            diagram_type = "module"
        else:
            diagram = generate_class_diagram(visitors, functions)
            diagram_type = "class"

        # Determine the output file
        if output:
            output_path = Path(output)
        else:
            # Use a default output file based on the input path
            base_name = input_path.stem if input_path.is_file() else input_path.name
            output_path = (
                settings.output_dir
                / "code_analysis"
                / f"{base_name}_{diagram_type}_diagram.puml"
            )

        # Save the diagram
        save_diagram(diagram, output_path)
        logger.info(f"Generated {diagram_type} diagram: {output_path}")

        return output_path
    except (InvalidPathError, NoFilesAnalyzedError):
        raise
    except Exception as e:
        raise AnalyzerError(f"Error analyzing and generating diagram: {e}")

================
File: config.py
================
"""
PlantUML Configuration

This module contains configuration settings for the PlantUML utilities.
"""

import os
import sys


# Determine the project root directory more robustly
def get_project_root():
    """
    Get the project root directory in a way that works regardless of where the code is executed from.

    Returns:
        str: The absolute path to the project root directory
    """
    # Start with the directory containing this file
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # Try to find the project root by looking for key directories/files
    # that indicate the project root
    potential_root = current_dir
    for _ in range(5):  # Limit the search depth to avoid infinite loops
        # Check if this looks like the project root
        if os.path.isdir(os.path.join(potential_root, "docs")) and os.path.isdir(
            os.path.join(potential_root, "utils")
        ):
            return potential_root

        # Move up one directory
        parent = os.path.dirname(potential_root)
        if parent == potential_root:  # We've reached the filesystem root
            break
        potential_root = parent

    # If we couldn't find a definitive project root, use the default approach
    return os.path.dirname(os.path.dirname(os.path.dirname(current_dir)))


# Project root directory
PROJECT_ROOT = get_project_root()

# Default source directory for diagrams
SOURCE_DIR = os.path.join(PROJECT_ROOT, "docs", "diagrams")

# Default output directory for rendered diagrams
OUTPUT_DIR = os.path.join(SOURCE_DIR, "output")

# PlantUML server URLs
PLANTUML_SERVER_SVG = "http://www.plantuml.com/plantuml/svg/"
PLANTUML_SERVER_PNG = "http://www.plantuml.com/plantuml/img/"

# Supported output formats
FORMATS: list[str] = ["svg", "png"]

# Default output format
DEFAULT_FORMAT = "svg"

# Add the project root to sys.path to ensure imports work correctly
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

================
File: core.py
================
"""
PlantUML Core Utilities

This module provides core utilities and shared functionality for the PlantUML package.
"""

import logging
from pathlib import Path

from .exceptions import LoggingError, PathError
from .settings import settings


def setup_logger(name: str = "puml", verbose: bool | None = None) -> logging.Logger:
    """
    Set up and configure a logger with consistent formatting.

    Args:
        name: Logger name
        verbose: Override the global verbose setting

    Returns:
        Configured logger instance

    Raises:
        LoggingError: If there is an error configuring the logger
    """
    try:
        # Use provided verbose setting or fall back to global setting
        is_verbose = verbose if verbose is not None else settings.verbose
        level = logging.DEBUG if is_verbose else logging.INFO

        # Get or create logger
        logger = logging.getLogger(name)
        logger.setLevel(level)

        # Only add handler if none exist
        if not logger.handlers and not (logger.parent and logger.parent.handlers):
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter(settings.log_format))
            logger.addHandler(handler)

        return logger
    except Exception as e:
        raise LoggingError(f"Failed to setup logger: {e}") from e


def ensure_dir_exists(path: str | Path) -> Path:
    """
    Ensure a directory exists, creating it if necessary.

    Args:
        path: Directory path to ensure exists

    Returns:
        Path object for the directory

    Raises:
        PathError: If the directory cannot be created
    """
    try:
        path_obj = Path(path)
        path_obj.mkdir(parents=True, exist_ok=True)
        return path_obj
    except Exception as e:
        raise PathError(f"Failed to create directory {path}: {e}") from e


def get_relative_path(path: str | Path, base_dir: str | Path) -> Path:
    """
    Get the path relative to a base directory.

    Args:
        path: Path to get relative path for
        base_dir: Base directory to get path relative to

    Returns:
        Relative path from base_dir to path

    Raises:
        PathError: If the relative path cannot be determined
    """
    try:
        path_obj = Path(path).resolve()
        base_obj = Path(base_dir).resolve()

        # Handle the case where path is a file
        if path_obj.is_file():
            path_obj = path_obj.parent

        return path_obj.relative_to(base_obj)
    except ValueError as e:
        raise PathError(f"Could not determine relative path: {e}") from e


def get_output_path(input_file: str | Path, format: str) -> Path:
    """
    Generate the output path for a rendered diagram.

    Args:
        input_file: Path to the input .puml file
        format: Output format (e.g., 'svg', 'png')

    Returns:
        Path where the rendered diagram should be saved

    Raises:
        PathError: If the output path cannot be determined
    """
    try:
        # Get path relative to source directory
        rel_path = get_relative_path(input_file, settings.source_dir)

        # Create output subdirectory matching source structure
        output_subdir = settings.output_dir / rel_path
        ensure_dir_exists(output_subdir)

        # Generate output filename
        input_path = Path(input_file)
        output_name = input_path.stem + f".{format}"
        return output_subdir / output_name
    except Exception as e:
        raise PathError(f"Failed to generate output path: {e}") from e


# Initialize logger for this module
logger = setup_logger(__name__)

================
File: docs/plantuml-utilities.md
================
# SOP-004: Using PlantUML Utilities

## Purpose

This procedure describes how to use the PlantUML utilities to create, render,
and view diagrams for the project. PlantUML is a tool that allows
you to create diagrams from text-based descriptions, making it easier to version
control and maintain diagrams.

## Scope

This procedure covers:

- Creating PlantUML diagram files
- Rendering diagrams to SVG or PNG format
- Viewing rendered diagrams with the React viewer
- Adding new diagrams to the project

This procedure does not cover:

- Installing PlantUML server
- Advanced PlantUML syntax and features

## Prerequisites

- Access to the project repository
- Python 3.6 or higher
- Virtual environment set up (optional but recommended)
- Basic understanding of PlantUML syntax

## Procedure

### 1. Install Required Dependencies

1. Activate the virtual environment (if using one):

   ```bash
   # For Windows Command Prompt/PowerShell
   .\.venv\Scripts\activate

   # For Git Bash/MINGW (Windows)
   source .venv/Scripts/activate

   # For macOS/Linux
   source .venv/bin/activate
   ```

2. Install the plantuml package:

   ```bash
   pip install plantuml
   ```

### 2. Create or Modify PlantUML Diagrams

1. Navigate to the `docs/diagrams` directory:

   ```bash
   cd docs/diagrams
   ```

2. Create a new directory for your diagrams if needed:

   ```bash
   mkdir -p your-category
   ```

3. Create or edit a PlantUML file (with `.puml` extension):

   ```bash
   # Example: Create a new diagram
   touch your-category/your-diagram.puml
   ```

4. Edit the file with your PlantUML code:

   ```plantuml
   @startuml "Your Diagram Title"

   ' Your PlantUML code here
   class Example {
     +attribute: Type
     +method(): ReturnType
   }

   @enduml
   ```

### 3. Render Diagrams

1. Return to the project root directory:

   ```bash
   cd /c/Repos/my-full-stack-fastapi-template  # For Git Bash
   # OR
   cd c:\Repos\my-full-stack-fastapi-template  # For Windows Command Prompt
   ```

2. Render all diagrams to SVG format (default):

   ```bash
   python -m utils.puml.cli render
   ```

3. Alternatively, render to PNG format:

   ```bash
   python -m utils.puml.cli render --format=png
   ```

4. To render a specific diagram:

   ```bash
   python -m utils.puml.cli render --file=your-category/your-diagram.puml
   ```

5. For best results, render both SVG and PNG formats:

   ```bash
   python -m utils.puml.cli render
   python -m utils.puml.cli render --format=png
   ```

### 4. View Diagrams with the React Viewer

1. Open the React viewer in your default browser:

   ```bash
   python -m utils.puml.cli view
   ```

   Or use the Make command:

   ```bash
   make view-diagrams
   ```

2. The React viewer will:

   - Automatically detect all diagram folders
   - Display all diagrams in each folder
   - Allow switching between SVG and PNG formats
   - Provide zoom controls for each diagram

3. Using the viewer interface:
   - Click on folder tabs in the sidebar to switch between diagram categories
   - Use the PNG/SVG buttons to switch formats
   - Use the zoom controls to zoom in, zoom out, or reset the zoom
   - Diagrams are displayed with formatted titles

### 5. Adding New Diagram Categories

1. To add a new diagram category:

   - Create a new directory under `docs/diagrams/`
   - Add your `.puml` files to this directory
   - Render the diagrams as described in section 3
   - The new category will automatically appear in the React viewer **if it's one of the known folders**

2. The React viewer automatically detects diagrams in the following folders:
   - `architecture`
   - `classifier`
   - `database`

3. If you add a new diagram to one of these folders, it will be automatically detected.
   However, if you add a new folder, you'll need to update the `knownFolders` array in
   `utils/puml/viewer/index.html`.

### 6. Using Make Commands (Recommended)

1. From the project root directory, use Make commands:

   ```bash
   # Render all diagrams to SVG
   make render-diagrams

   # Render all diagrams to PNG
   make render-diagrams-png

   # View diagrams
   make view-diagrams
   ```

## Verification

To verify that the procedure was completed successfully:

1. Check that the rendered diagrams exist in the `docs/diagrams/output`
   directory
2. Verify that the diagrams are displayed correctly in the React viewer
3. Confirm that both SVG and PNG formats can be viewed
4. Verify that all diagram categories appear in the sidebar
5. Confirm that all diagrams within each category are displayed

## Troubleshooting

### Common Issues

1. **Module not found error: `plantuml`**

   - Solution: Install the plantuml package with `pip install plantuml`

2. **Path issues in Git Bash**

   - Solution: Use forward slashes for paths and ensure the virtual environment
     is activated with `source .venv/Scripts/activate`

3. **Diagrams not rendering**

   - Solution: Check that the PlantUML syntax is correct and that the file has a
     `.puml` extension

4. **React viewer not showing diagrams**

   - Solution: Ensure that diagrams have been rendered first with
     `python -m utils.puml.cli render`
   - Check browser console for any JavaScript errors
   - Verify that both SVG and PNG files exist in the output directory

5. **New diagrams not appearing in the viewer**

   - Solution: Refresh the browser page after rendering new diagrams
   - Check that the diagrams were rendered successfully
   - Verify the diagram files exist in the correct output subdirectory

6. **Configuration issues**
   - Solution: Check the `utils/puml/config.py` file for correct paths and settings

## References

- [PlantUML Official Documentation](https://plantuml.com/en/guide)
- [PlantUML Syntax Guide](https://plantuml.com/en/guide)
- [Project PlantUML Utilities README](../../utils/puml/README.md)

## Revision History

| Version | Date       | Author | Changes                                |
| ------- | ---------- | ------ | -------------------------------------- |
| 1.0     | 2025-03-04 | Roo    | Initial version                        |
| 1.1     | 2025-03-05 | Roo    | Updated for dynamic HTML viewer        |
| 1.2     | 2025-03-11 | Roo    | Updated for React viewer and refactoring |

================
File: docs/README.md
================
# PlantUML Utilities

This package provides utilities for working with PlantUML diagrams in the project.

## Features

- Render PlantUML diagrams to PNG or SVG images
- View rendered diagrams in a React-based viewer
- Analyze code and generate PlantUML diagrams automatically
- Command-line interface for rendering, viewing, and analyzing code

## Requirements

- Python 3.6+
- plantuml package (`pip install plantuml`)
- Internet connection (for the PlantUML server)

## Usage

### Command Line Interface

```bash
# Render all diagrams to SVG (default)
make render-diagrams

# Render all diagrams to PNG
make render-diagrams-png

# View diagrams in the React viewer
make view-diagrams
```

Or use the Python CLI directly:

```bash
# Render all diagrams to SVG (default)
python -m utils.puml.cli render

# Render all diagrams to PNG
python -m utils.puml.cli render --format=png

# Render a specific diagram
python -m utils.puml.cli render --file=classifier/classifier_model_diagram.puml

# View diagrams in the React viewer
python -m utils.puml.cli view

# Analyze code and generate a class diagram
python -m utils.puml.cli analyze --path=path/to/code

# Analyze code and generate a module diagram
python -m utils.puml.cli analyze --path=path/to/code --modules

# Analyze code and include standalone functions in the class diagram
python -m utils.puml.cli analyze --path=path/to/code --functions

# Analyze code with verbose logging
python -m utils.puml.cli analyze --path=path/to/code --verbose
```

### Python API

```python
from utils.puml import render_diagram, render_all_diagrams

# Render a specific diagram to PNG
render_diagram('docs/diagrams/classifier/classifier_model_diagram.puml',
               output_dir='docs/diagrams/output',
               format='png')

# Render all diagrams to SVG
render_all_diagrams('docs/diagrams',
                    output_dir='docs/diagrams/output',
                    format='svg')
```

### Code Analysis API

```python
from utils.puml import (
    analyze_directory, analyze_file,
    generate_class_diagram, generate_module_diagram,
    save_diagram, analyze_and_generate_diagram
)

# Quick way to analyze code and generate a diagram
output_file = analyze_and_generate_diagram(
    path='path/to/code',
    modules=False,  # Set to True for module diagram
    functions=True  # Include standalone functions
)

# Or use the individual functions for more control
visitors = analyze_directory('path/to/code')

# Generate a class diagram
class_diagram = generate_class_diagram(visitors, include_functions=True)

# Generate a module diagram
module_diagram = generate_module_diagram(visitors)

# Save the diagram to a file
save_diagram(class_diagram, 'docs/diagrams/code_analysis/class_diagram.puml')
```

## Configuration

Configuration settings are stored in `utils/puml/config.py`. You can modify these settings to change the default behavior of the utilities.

```python
# Default source directory for diagrams
SOURCE_DIR = os.path.join(PROJECT_ROOT, "docs", "diagrams")

# Default output directory for rendered diagrams
OUTPUT_DIR = os.path.join(SOURCE_DIR, "output")

# Default output format
DEFAULT_FORMAT = "svg"
```

## Directory Structure

```
utils/puml/
├── __init__.py          # Package initialization and public API
├── config.py            # Configuration settings
├── core.py              # Core utilities and shared functions
├── cli.py               # Command-line interface
├── render_diagrams.py   # Diagram rendering functions
├── code_analyzer.py     # Code analysis and diagram generation
├── test_puml.py         # Test script for rendering
├── test_code_analyzer.py # Test script for code analysis
├── viewer/              # React-based diagram viewer
│   └── index.html       # Viewer HTML file
└── README.md            # This file
```

## Adding New Diagrams

1. Create a new `.puml` file in the `docs/diagrams` directory
2. Run `make render-diagrams` to render the diagram
3. Run `make view-diagrams` to view the diagram in the React viewer

**Note:** The React viewer automatically detects diagrams in the following folders:

- `architecture`
- `classifier`
- `database`

If you add a new diagram to one of these folders, it will be automatically detected. However, if you add a new folder, you'll need to update the `knownFolders` array in `utils/puml/viewer/index.html`.

## Analyzing Code

The code analyzer can generate PlantUML diagrams from your Python code automatically. It analyzes the code structure and creates diagrams showing classes, functions, and their relationships.

### Class Diagrams

Class diagrams show the classes in your code, their attributes, methods, and inheritance relationships:

```bash
# Analyze a specific file
python -m utils.puml.cli analyze --path=path/to/file.py

# Analyze a directory (recursively)
python -m utils.puml.cli analyze --path=path/to/directory

# Include standalone functions in the diagram
python -m utils.puml.cli analyze --path=path/to/code --functions
```

### Module Diagrams

Module diagrams show the dependencies between modules in your code:

```bash
# Generate a module diagram
python -m utils.puml.cli analyze --path=path/to/code --modules
```

### Workflow

1. Analyze your code to generate a PlantUML diagram:

   ```bash
   python -m utils.puml.cli analyze --path=backend/app
   ```

2. Render the generated diagram:

   ```bash
   python -m utils.puml.cli render --file=code_analysis/app_class_diagram.puml
   ```

3. View the rendered diagram:

   ```bash
   python -m utils.puml.cli view
   ```

The generated diagrams will be saved in the `docs/diagrams/output/code_analysis` directory.

## Troubleshooting

- If the diagrams are not rendering, check your internet connection. The PlantUML server requires an internet connection to render diagrams.
- If the viewer is not showing the diagrams, make sure you have rendered the diagrams first using `make render-diagrams`.
- If the code analyzer is not finding all classes or relationships, try using the `--verbose` flag to see more detailed logging: `python -m utils.puml.cli analyze --path=path/to/code --verbose`
- If the generated diagrams are too complex or cluttered, try analyzing smaller portions of your codebase or specific files instead of entire directories.
- For large codebases, the module diagram (`--modules`) might be more readable than the class diagram.

================
File: exceptions.py
================
"""
PlantUML Utilities Exceptions

This module defines custom exceptions used throughout the PlantUML utilities package.
"""


class PlantUMLError(Exception):
    """Base exception for all PlantUML utility errors."""

    pass


class ConfigurationError(PlantUMLError):
    """Raised when there is a configuration-related error."""

    pass


class ProjectRootError(ConfigurationError):
    """Raised when the project root directory cannot be determined."""

    pass


class PathError(PlantUMLError):
    """Raised when there is a path-related error."""

    pass


class RenderError(PlantUMLError):
    """Raised when there is an error rendering a diagram."""

    pass


class LoggingError(PlantUMLError):
    """Raised when there is a logging-related error."""

    pass


class AnalyzerError(PlantUMLError):
    """Base exception for code analyzer errors."""

    pass


class InvalidPathError(AnalyzerError):
    """Raised when an invalid path is provided."""

    def __init__(self, path: str):
        self.path = path
        super().__init__(f"Path does not exist or is not a Python file: {path}")


class NoFilesAnalyzedError(AnalyzerError):
    """Raised when no Python files were successfully analyzed."""

    def __init__(self):
        super().__init__("No Python files were successfully analyzed")


class ParseError(AnalyzerError):
    """Raised when there is an error parsing Python code."""

    def __init__(self, path: str, error: Exception):
        self.path = path
        self.original_error = error
        super().__init__(f"Error parsing {path}: {error}")


class DiagramGenerationError(AnalyzerError):
    """Raised when there is an error generating a diagram."""

    pass

================
File: Makefile
================
# PlantUML Utilities Makefile

# Render all PlantUML diagrams to SVG (default)
render-diagrams:
	python -m utils.puml.cli render
	@echo "Diagrams saved to docs/diagrams/output"

# Render all PlantUML diagrams to PNG
render-diagrams-png:
	python -m utils.puml.cli render --format=png

# Render a specific PlantUML diagram
render-diagram:
	@echo "Usage: make render-diagram FILE=<file>"
	@if [ "$(FILE)" ]; then \
		python -m utils.puml.cli render --file=$(FILE); \
	fi

# Open the PlantUML HTML viewer
view-diagrams:
	# Open the HTML file directly instead of using the CLI
	start docs/diagrams/output/index.html 2>/dev/null || \
	open docs/diagrams/output/index.html 2>/dev/null || \
	xdg-open docs/diagrams/output/index.html 2>/dev/null || \
	echo "Could not open the HTML viewer automatically. Please open docs/diagrams/output/index.html manually."

# Show help
help:
	@echo "PlantUML Utilities Makefile"
	@echo ""
	@echo "Commands:"
	@echo "  make render-diagrams       - Render all PlantUML diagrams to SVG"
	@echo "  make render-diagrams-png   - Render all PlantUML diagrams to PNG"
	@echo "  make render-diagram FILE=<file> - Render a specific PlantUML diagram"
	@echo "  make view-diagrams         - Open the PlantUML HTML viewer"
	@echo "  make help                  - Show this help message"
	@echo ""
	@echo "Example:"
	@echo "  make render-diagram FILE=classifier/classifier_model_diagram.puml"

.PHONY: render-diagrams render-diagrams-png render-diagram view-diagrams help

================
File: render_diagrams.py
================
"""
PlantUML Diagram Renderer

This module renders PlantUML diagrams to PNG or SVG images using the plantuml Python package.
It can be used as an alternative to the HTML viewer if you prefer local rendering.

Requirements:
- Python 3.6+
- plantuml package (pip install plantuml)
- Internet connection (for the PlantUML server)
"""

import re
from pathlib import Path

import plantuml  # type: ignore

from .core import ensure_dir_exists, get_output_path, setup_logger
from .exceptions import RenderError
from .settings import settings

# Set up logger
logger = setup_logger("render_diagrams")


def render_diagram(
    puml_file: str | Path,
    output_dir: str | Path | None = None,
    format: str = settings.default_format,
) -> bool:
    """
    Render a PlantUML diagram to an image.

    Args:
        puml_file: Path to the PlantUML file
        output_dir: Directory to save the rendered image (default: settings.output_dir)
        format: Output format (png or svg, default: settings.default_format)

    Returns:
        True if successful, False otherwise

    Raises:
        RenderError: If there is an error rendering the diagram
    """
    try:
        # Convert paths to Path objects
        puml_path = Path(puml_file)
        out_dir = Path(output_dir) if output_dir else settings.output_dir

        # Create output directory if it doesn't exist
        ensure_dir_exists(out_dir)

        # Get the output file path
        output_file = get_output_path(puml_path, format)

        # Check if the output file already exists and is newer than the input file
        if output_file.exists():
            puml_mtime = puml_path.stat().st_mtime
            output_mtime = output_file.stat().st_mtime
            if output_mtime > puml_mtime:
                logger.info(f"Skipping {puml_path} (already rendered and up to date)")
                return True

        # Create a PlantUML server instance with the appropriate URL for the format
        server_url = (
            settings.plantuml_server_svg
            if format.lower() == "svg"
            else settings.plantuml_server_png
        )
        plantuml_server = plantuml.PlantUML(url=server_url)

        # Generate the diagram
        logger.info(f"Rendering {puml_path} to {format.upper()}...")
        plantuml_server.processes_file(str(puml_path), outfile=str(output_file))
        logger.info(f"Saved to {output_file}")
        return True

    except Exception as e:
        raise RenderError(f"Error rendering {puml_file}: {e}") from e


def update_viewer_index(output_dir: str | Path | None = None) -> None:
    """
    Update the index.html file with the new diagrams.

    Args:
        output_dir: Directory containing rendered images (default: settings.output_dir)

    Raises:
        RenderError: If there is an error updating the index file
    """
    try:
        out_dir = Path(output_dir) if output_dir else settings.output_dir
        index_path = out_dir / "index.html"

        if not index_path.exists():
            logger.warning(f"Index file not found at {index_path}")
            return

        # Read the index.html file
        content = index_path.read_text(encoding="utf-8")

        # Find the scanDiagramsInFolder function
        pattern = r"function scanDiagramsInFolder\(folder\) \{(.*?)return \[\];\s*\}"
        match = re.search(pattern, content, re.DOTALL)
        if not match:
            logger.warning("Could not find scanDiagramsInFolder function in index.html")
            return

        # Get all diagram folders
        folders: dict[str, list[str]] = {}
        for path in out_dir.glob("**/*.svg"):
            if path.parent == out_dir:
                continue

            folder_name = path.parent.name
            if folder_name not in folders:
                folders[folder_name] = []

            folders[folder_name].append(path.stem)

        # Build the new function content
        new_function = [
            "function scanDiagramsInFolder(folder) {",
            "        // In a browser environment with local files, we can't use fetch to check if files exist",
            "        // So we'll just return the diagrams we know exist based on the folder",
            "",
        ]

        # Add each folder's diagrams
        first_folder = True
        for folder, diagrams in folders.items():
            if diagrams:
                if first_folder:
                    new_function.append(f"        if (folder === '{folder}') {{")
                    first_folder = False
                else:
                    new_function.append(f"        else if (folder === '{folder}') {{")

                # Format the diagrams list as a JavaScript array
                diagrams_str = str(diagrams).replace("'", '"')
                new_function.append(f"          return {diagrams_str};")
                new_function.append("        }")

        # Add the default case
        if first_folder:
            new_function.append("        return [];")
        else:
            new_function.extend(
                [
                    " else {",
                    "          return [];",
                    "        }",
                ]
            )

        new_function.extend(
            [
                "",
                "        return [];",
                "      }",
            ]
        )

        # Replace the function in the content
        new_content = re.sub(
            pattern,
            "\n".join(new_function),
            content,
            flags=re.DOTALL,
        )

        # Write the updated content back to the file
        index_path.write_text(new_content, encoding="utf-8")
        logger.info(
            f"Updated index.html with {sum(len(diagrams) for diagrams in folders.values())} diagrams",
        )

    except Exception as e:
        raise RenderError(f"Error updating index file: {e}") from e


def render_all_diagrams(
    directory: str | Path | None = None,
    output_dir: str | Path | None = None,
    format: str = settings.default_format,
) -> tuple[int, int]:
    """
    Render all PlantUML diagrams in the specified directory.

    Args:
        directory: Directory containing PlantUML files (default: settings.source_dir)
        output_dir: Directory to save rendered images (default: settings.output_dir)
        format: Output format (png or svg, default: settings.default_format)

    Returns:
        Tuple of (success_count, total_count)

    Raises:
        RenderError: If there is an error rendering the diagrams
    """
    try:
        # Convert paths to Path objects
        src_dir = Path(directory) if directory else settings.source_dir
        out_dir = Path(output_dir) if output_dir else settings.output_dir

        # Find all .puml files in the directory and its subdirectories
        puml_files = list(src_dir.glob("**/*.puml"))

        if not puml_files:
            logger.warning(f"No .puml files found in {src_dir}")
            return (0, 0)

        # Create output directory
        ensure_dir_exists(out_dir)

        # Render each diagram
        success_count = 0
        for puml_path in puml_files:
            if render_diagram(puml_path, out_dir, format):
                success_count += 1

        # Print summary
        logger.info(
            f"Rendered {success_count} of {len(puml_files)} diagrams to {out_dir}",
        )

        # Update the index.html file
        update_viewer_index(out_dir)

        return (success_count, len(puml_files))

    except Exception as e:
        raise RenderError(f"Error rendering diagrams: {e}") from e


def launch_viewer() -> bool:
    """
    Launch the PlantUML viewer in the default web browser.

    Returns:
        True if successful, False otherwise

    Raises:
        RenderError: If there is an error launching the viewer
    """
    try:
        import webbrowser

        # Get the path to the React HTML viewer
        viewer_path = Path(__file__).parent / "viewer" / "index.html"

        # Check if the viewer exists
        if not viewer_path.exists():
            raise RenderError(f"React HTML viewer not found: {viewer_path}")

        # Check if the output directory exists
        if not settings.output_dir.exists():
            raise RenderError(
                f"Output directory not found: {settings.output_dir}\n"
                "Please render the diagrams first using the 'render' command.",
            )

        # Open the viewer in the default web browser
        logger.info(f"Opening React HTML viewer: {viewer_path}")
        webbrowser.open(f"file://{viewer_path.resolve()}")

        return True

    except Exception as e:
        raise RenderError(f"Error launching viewer: {e}") from e

================
File: settings.py
================
"""
PlantUML Utilities Settings

This module provides a centralized configuration system using Pydantic.
"""

import sys
from pathlib import Path
from typing import Union

from pydantic import BaseModel, Field, validator

from .exceptions import ProjectRootError

PathLike = Union[str, Path]


class PlantUMLSettings(BaseModel):
    """PlantUML utilities configuration settings."""

    # Project structure
    project_root: Path = Field(description="Project root directory")
    source_dir: Path = Field(description="Source directory for PlantUML files")
    output_dir: Path = Field(description="Output directory for rendered diagrams")

    # PlantUML server configuration
    plantuml_server_svg: str = Field(
        default="http://www.plantuml.com/plantuml/svg/",
        description="PlantUML server URL for SVG format",
    )
    plantuml_server_png: str = Field(
        default="http://www.plantuml.com/plantuml/img/",
        description="PlantUML server URL for PNG format",
    )

    # Output formats
    supported_formats: list[str] = Field(
        default=["svg", "png"],
        description="Supported output formats",
    )
    default_format: str = Field(
        default="svg",
        description="Default output format",
    )

    # Logging configuration
    verbose: bool = Field(
        default=False,
        description="Enable verbose logging",
    )
    log_format: str = Field(
        default="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        description="Logging format string",
    )

    @validator("project_root", pre=True)
    def validate_project_root(cls, v: PathLike | None) -> Path:
        """Validate and set the project root directory."""
        if v is None:
            v = cls._find_project_root()
        return Path(str(v)).resolve()

    @validator("source_dir", pre=True)
    def validate_source_dir(cls, v: PathLike | None, values: dict) -> Path:
        """Validate and set the source directory."""
        if v is None:
            project_root = values.get("project_root")
            if project_root is None:
                raise ProjectRootError(
                    "Project root must be set before source directory"
                )
            v = project_root / "docs" / "diagrams"

        path = Path(str(v)).resolve()
        path.mkdir(parents=True, exist_ok=True)
        return path

    @validator("output_dir", pre=True)
    def validate_output_dir(cls, v: PathLike | None, values: dict) -> Path:
        """Validate and set the output directory."""
        if v is None:
            source_dir = values.get("source_dir")
            if source_dir is None:
                raise ProjectRootError(
                    "Source directory must be set before output directory"
                )
            v = source_dir / "output"

        path = Path(str(v)).resolve()
        path.mkdir(parents=True, exist_ok=True)
        return path

    @validator("default_format")
    def validate_default_format(cls, v: str, values: dict) -> str:
        """Validate the default format is supported."""
        if v not in values["supported_formats"]:
            raise ValueError(
                f"Default format '{v}' must be one of {values['supported_formats']}"
            )
        return v

    @classmethod
    def _find_project_root(cls) -> Path:
        """Find the project root directory by looking for key markers."""
        current_dir = Path(__file__).parent

        for _ in range(10):  # Limit search depth
            if (current_dir / "docs").is_dir() and (current_dir / "utils").is_dir():
                return current_dir

            parent = current_dir.parent
            if parent == current_dir:  # Reached filesystem root
                break
            current_dir = parent

        raise ProjectRootError("Could not determine project root directory")

    class Config:
        """Pydantic configuration."""

        validate_assignment = True
        arbitrary_types_allowed = True
        json_encoders = {
            Path: str,
        }


def get_settings() -> PlantUMLSettings:
    """Get the global settings instance."""
    project_root = PlantUMLSettings._find_project_root()
    source_dir = project_root / "docs" / "diagrams"
    output_dir = source_dir / "output"

    settings = PlantUMLSettings(
        project_root=project_root,
        source_dir=source_dir,
        output_dir=output_dir,
    )

    # Add project root to Python path
    if str(settings.project_root) not in sys.path:
        sys.path.insert(0, str(settings.project_root))

    return settings


# Create a global settings instance
settings = get_settings()

================
File: tests/__init__.py
================
"""
PlantUML Utilities Test Package

This package contains tests for the PlantUML utilities.
"""

================
File: tests/test_code_analyzer.py
================
"""
Test Code Analyzer

This script tests the code analyzer by analyzing the code_analyzer.py file itself
and generating a class diagram from it.
"""

import os
import sys

# Add the project root to sys.path to ensure imports work correctly
project_dir = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
)
if project_dir not in sys.path:
    sys.path.insert(0, project_dir)

# Add the parent directory to path to allow relative imports
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

# Import the puml modules - try different import strategies
try:
    # First try relative imports (when running as a module)
    from ..code_analyzer import analyze_file, generate_class_diagram, save_diagram
    from ..config import OUTPUT_DIR
    from ..core import ensure_dir_exists, setup_logger
except (ImportError, ValueError):
    try:
        # Then try direct imports (when running from the utils/puml directory)
        from code_analyzer import analyze_file, generate_class_diagram, save_diagram
        from config import OUTPUT_DIR
        from core import ensure_dir_exists, setup_logger
    except ImportError:
        # Finally fall back to absolute imports (when running from project root)
        from utils.puml.code_analyzer import (
            analyze_file,
            generate_class_diagram,
            save_diagram,
        )
        from utils.puml.config import OUTPUT_DIR
        from utils.puml.core import ensure_dir_exists, setup_logger

# Configure logging
logger = setup_logger("test_code_analyzer", verbose=True)


def test_code_analyzer():
    """Test the code analyzer by analyzing itself."""
    # Get the path to the code_analyzer.py file
    script_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(script_dir)
    code_analyzer_path = os.path.join(parent_dir, "code_analyzer.py")

    # Make sure the file exists
    if not os.path.exists(code_analyzer_path):
        logger.error(f"Code analyzer file not found: {code_analyzer_path}")
        return 1

    # Analyze the file
    logger.info(f"Analyzing file: {code_analyzer_path}")
    visitor = analyze_file(code_analyzer_path)
    if not visitor:
        logger.error("Failed to analyze the file")
        return 1

    # Generate a class diagram
    logger.info("Generating class diagram")
    diagram = generate_class_diagram([visitor], include_functions=True)

    # Create the output directory if it doesn't exist
    code_analysis_dir = os.path.join(OUTPUT_DIR, "code_analysis")
    ensure_dir_exists(code_analysis_dir)

    # Save the diagram
    output_file = os.path.join(code_analysis_dir, "code_analyzer_class_diagram.puml")
    save_diagram(diagram, output_file)

    logger.info(f"Saved diagram to {output_file}")
    logger.info(
        "You can render it using: python -m utils.puml.cli render --file=code_analysis/code_analyzer_class_diagram.puml",
    )

    return 0


if __name__ == "__main__":
    sys.exit(test_code_analyzer())

================
File: tests/test_puml.py
================
"""
PlantUML Utilities Test Script

This script tests the PlantUML utilities to ensure they are working correctly.
It checks that the diagrams can be loaded and rendered.

Usage:
    python test_puml.py
"""

import os
import sys
import unittest
from pathlib import Path
from typing import Protocol, TypeVar, Union

# Add the project root to sys.path to ensure imports work correctly
project_dir = os.path.dirname(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))),
)
if project_dir not in sys.path:
    sys.path.insert(0, project_dir)

# Define type variables for better type hints
PathLike = Union[str, Path]
P = TypeVar("P", str, Path)


# Define protocols for our functions
class EnsureDirExistsProtocol(Protocol):
    def __call__(self, path: PathLike) -> Path: ...


class RenderDiagramProtocol(Protocol):
    def __call__(
        self, puml_file: str, output_dir: str | None = None, format: str = "svg"
    ) -> bool: ...


# Define a function to get the source directory
def get_source_dir() -> Path:
    """Get the source directory for diagrams."""
    current_dir = Path(__file__).parent
    project_root = current_dir.parent.parent.parent
    return project_root / "docs" / "diagrams"


# Set default values
SOURCE_DIR = get_source_dir()


# Define fallback functions in case imports fail
def default_ensure_dir_exists(path: PathLike) -> Path:
    """Ensure a directory exists."""
    path_obj = Path(path)
    path_obj.mkdir(parents=True, exist_ok=True)
    return path_obj


def default_render_diagram(
    puml_file: str,
    output_dir: str | None = None,
    format: str = "svg",
) -> bool:
    """Stub for render_diagram if import fails."""
    print(f"Warning: Using stub render_diagram function for {puml_file}")
    return False


# Set initial values to the default functions
ensure_dir_exists: EnsureDirExistsProtocol = default_ensure_dir_exists
render_diagram: RenderDiagramProtocol = default_render_diagram

# Import the required modules
try:
    # Try absolute imports first (when running from project root)
    from utils.puml.core import ensure_dir_exists as core_ensure_dir_exists
    from utils.puml.render_diagrams import render_diagram as render_diagram_func
    from utils.puml.settings import settings

    # Update the variables with the imported functions
    SOURCE_DIR = settings.source_dir
    ensure_dir_exists = core_ensure_dir_exists
    render_diagram = render_diagram_func
except ImportError:
    try:
        # Then try relative imports (when running as a module)
        from ..core import ensure_dir_exists as core_ensure_dir_exists
        from ..render_diagrams import render_diagram as render_diagram_func
        from ..settings import settings

        # Update the variables with the imported functions
        SOURCE_DIR = settings.source_dir
        ensure_dir_exists = core_ensure_dir_exists
        render_diagram = render_diagram_func
    except (ImportError, ValueError):
        try:
            # Finally try direct imports (when running from the utils/puml directory)
            from core import ensure_dir_exists as core_ensure_dir_exists
            from render_diagrams import render_diagram as render_diagram_func
            from settings import settings

            # Update the variables with the imported functions
            SOURCE_DIR = settings.source_dir
            ensure_dir_exists = core_ensure_dir_exists
            render_diagram = render_diagram_func
        except ImportError:
            # If all imports fail, we'll use the default functions and SOURCE_DIR
            pass


class TestPlantUML(unittest.TestCase):
    """Test case for PlantUML utilities."""

    def setUp(self):
        """Set up the test case."""
        # Get the directory containing this script
        self.script_dir = Path(__file__).parent

        # Create a temporary output directory
        self.output_dir = self.script_dir / "test_output"
        ensure_dir_exists(self.output_dir)

    def tearDown(self):
        """Clean up after the test case."""
        # Remove the temporary output directory and its contents
        if self.output_dir.exists():
            # Walk through all files and directories
            for item in self.output_dir.glob("**/*"):
                if item.is_file():
                    try:
                        item.unlink()
                    except (PermissionError, OSError) as e:
                        print(f"Warning: Could not remove file {item}: {e}")

            # Remove all empty directories
            for item in sorted(self.output_dir.glob("**/*"), reverse=True):
                if item.is_dir():
                    try:
                        item.rmdir()
                    except (PermissionError, OSError) as e:
                        print(f"Warning: Could not remove directory {item}: {e}")

            # Finally remove the output directory itself
            try:
                self.output_dir.rmdir()
            except (PermissionError, OSError) as e:
                print(
                    f"Warning: Could not remove output directory {self.output_dir}: {e}"
                )

    def test_diagram_files_exist(self):
        """Test that the diagram files exist."""
        # Check that the diagram files exist
        diagram_files = [
            "architecture/puml_utilities.puml",
            "architecture/puml_viewer_class_diagram.puml",
        ]

        for file in diagram_files:
            file_path = SOURCE_DIR / file
            self.assertTrue(
                file_path.exists(),
                f"Diagram file not found: {file_path}",
            )

    def test_render_diagram_png(self):
        """Test that a diagram can be rendered to PNG."""
        # Get the path to a diagram file
        diagram_file = SOURCE_DIR / "architecture" / "puml_utilities.puml"

        # Render the diagram with explicit output directory
        result = render_diagram(str(diagram_file), str(self.output_dir), "png")

        # Check that the rendering was successful
        self.assertTrue(result, "Diagram rendering failed")

        # Check that the output file was created (with preserved directory structure)
        output_file = self.output_dir / "architecture" / "puml_utilities.png"
        self.assertTrue(
            output_file.exists(),
            f"Output file not found: {output_file}",
        )

    def test_render_diagram_svg(self):
        """Test that a diagram can be rendered to SVG."""
        # Get the path to a diagram file
        diagram_file = SOURCE_DIR / "architecture" / "puml_viewer_class_diagram.puml"

        # Render the diagram with explicit output directory
        result = render_diagram(str(diagram_file), str(self.output_dir), "svg")

        # Check that the rendering was successful
        self.assertTrue(result, "Diagram rendering failed")

        # Check that the output file was created (with preserved directory structure)
        output_file = self.output_dir / "architecture" / "puml_viewer_class_diagram.svg"
        self.assertTrue(
            output_file.exists(),
            f"Output file not found: {output_file}",
        )


def main():
    """Run the tests."""
    unittest.main()


if __name__ == "__main__":
    main()

================
File: viewer/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PlantUML Diagram Viewer</title>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f5f5f5;
        height: 100vh;
        overflow: hidden;
      }
      .container {
        width: 100%;
        height: calc(100vh - 60px);
        margin: 0;
        padding: 0;
        display: flex;
      }
      .header {
        background-color: #333;
        color: white;
        padding: 10px 20px;
        height: 40px;
        display: flex;
        align-items: center;
      }
      .header h1 {
        margin: 0;
        font-size: 24px;
      }
      .sidebar {
        width: 250px;
        background-color: white;
        border-right: 1px solid #ddd;
        padding: 10px;
        height: 100%;
        overflow-y: auto;
        flex-shrink: 0;
      }
      .content {
        flex-grow: 1;
        padding: 20px;
        background-color: white;
        height: 100%;
        overflow-y: auto;
      }
      .folder {
        margin-bottom: 15px;
      }
      .folder-title {
        font-weight: bold;
        cursor: pointer;
        padding: 5px;
        background-color: #f0f0f0;
        border-radius: 3px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .folder-title:hover {
        background-color: #e0e0e0;
      }
      .diagram-list {
        margin-top: 5px;
        margin-left: 10px;
      }
      .diagram-item {
        padding: 5px;
        cursor: pointer;
        border-radius: 3px;
      }
      .diagram-item:hover {
        background-color: #f0f0f0;
      }
      .diagram-item.active {
        background-color: #e6f7ff;
        font-weight: bold;
      }
      .diagram-container {
        text-align: center;
        margin-top: 20px;
        border: 1px solid #ddd;
        background-color: #f8f9fa;
        overflow: hidden;
        height: 75vh;
      }
      .diagram-container img {
        max-width: none;
        border: none;
        display: block;
      }
      .format-toggle {
        margin-bottom: 10px;
        text-align: right;
      }
      .format-toggle button {
        padding: 5px 10px;
        margin-left: 5px;
        background-color: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
      }
      .format-toggle button.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
      }
      .zoom-controls {
        margin-bottom: 10px;
        text-align: right;
      }
      .zoom-controls button {
        padding: 5px 10px;
        margin-left: 5px;
        background-color: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
      }
      .no-diagram {
        text-align: center;
        margin-top: 100px;
        color: #666;
      }
      .loading {
        text-align: center;
        margin-top: 100px;
        color: #666;
      }
      .error {
        color: #d9534f;
        padding: 10px;
        background-color: #f9f2f2;
        border-radius: 5px;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      // Main App component
      const App = () => {
        const [folders, setFolders] = React.useState({});
        const [loading, setLoading] = React.useState(true);
        const [error, setError] = React.useState(null);
        const [selectedFolder, setSelectedFolder] = React.useState(null);
        const [selectedDiagram, setSelectedDiagram] = React.useState(null);
        const [format, setFormat] = React.useState("svg");
        const [expandedFolders, setExpandedFolders] = React.useState({});
        const [zoom, setZoom] = React.useState(1);

        // Load diagram data
        React.useEffect(() => {
          const loadDiagrams = async () => {
            try {
              // In a real app, this would be an API call
              // For now, we'll just scan the output directory
              const data = await scanDiagrams();
              setFolders(data);

              // Select the first folder and diagram by default
              if (Object.keys(data).length > 0) {
                const firstFolder = Object.keys(data)[0];
                setSelectedFolder(firstFolder);
                setExpandedFolders({ [firstFolder]: true });

                if (data[firstFolder].length > 0) {
                  setSelectedDiagram(data[firstFolder][0]);
                }
              }

              setLoading(false);
            } catch (err) {
              setError(err.message);
              setLoading(false);
            }
          };

          loadDiagrams();
        }, []);

        // Function to scan for diagrams
        const scanDiagrams = async () => {
          try {
            const response = await fetch("http://localhost:8000/api/diagrams");
            if (!response.ok) {
              throw new Error(
                `Failed to fetch diagrams: ${response.statusText}`
              );
            }
            const data = await response.json();
            console.log("Loaded diagrams:", data);
            return data;
          } catch (err) {
            console.error(`Error scanning diagrams: ${err.message}`);
            throw err; // Let the error handler in useEffect handle it
          }
        };

        // Toggle folder expansion
        const toggleFolder = (folder) => {
          setExpandedFolders({
            ...expandedFolders,
            [folder]: !expandedFolders[folder],
          });
        };

        // Select a diagram
        const selectDiagram = (folder, diagram) => {
          setSelectedFolder(folder);
          setSelectedDiagram(diagram);
          setZoom(1); // Reset zoom when changing diagrams
        };

        // Format diagram name for display
        const formatDiagramName = (name) => {
          return name
            .replace(/_/g, " ")
            .replace(/\b\w/g, (l) => l.toUpperCase());
        };

        // State for panning and zooming
        const [transform, setTransform] = React.useState({
          x: 0,
          y: 0,
          scale: 1,
        });
        const [isDragging, setIsDragging] = React.useState(false);
        const [dragStart, setDragStart] = React.useState({ x: 0, y: 0 });
        const containerRef = React.useRef(null);

        // Zoom in
        const zoomIn = () => {
          setTransform((prev) => ({
            ...prev,
            scale: Math.min(prev.scale + 0.2, 5),
          }));
        };

        // Zoom out
        const zoomOut = () => {
          setTransform((prev) => ({
            ...prev,
            scale: Math.max(prev.scale - 0.2, 0.2),
          }));
        };

        // Reset zoom and position
        const resetView = () => {
          setTransform({
            x: 0,
            y: 0,
            scale: 1,
          });
        };

        // Start dragging
        const handleMouseDown = (e) => {
          // Only handle left mouse button
          if (e.button !== 0) return;

          setIsDragging(true);
          setDragStart({
            x: e.clientX - transform.x,
            y: e.clientY - transform.y,
          });

          // Change cursor
          if (containerRef.current) {
            containerRef.current.style.cursor = "grabbing";
          }
        };

        // Handle dragging
        const handleMouseMove = (e) => {
          if (!isDragging) return;

          setTransform((prev) => ({
            ...prev,
            x: e.clientX - dragStart.x,
            y: e.clientY - dragStart.y,
          }));
        };

        // End dragging
        const handleMouseUp = () => {
          setIsDragging(false);

          // Reset cursor
          if (containerRef.current) {
            containerRef.current.style.cursor = "grab";
          }
        };

        // Handle mouse wheel for zooming
        const handleWheel = (e) => {
          e.preventDefault();

          // Calculate zoom factor
          const delta = e.deltaY < 0 ? 0.2 : -0.2;
          const newScale = Math.max(0.2, Math.min(5, transform.scale + delta));

          // Get mouse position relative to container
          const containerRect = containerRef.current.getBoundingClientRect();
          const mouseX = e.clientX - containerRect.left;
          const mouseY = e.clientY - containerRect.top;

          // Calculate new position to zoom toward mouse position
          const scaleRatio = newScale / transform.scale;
          const newX = transform.x - (mouseX - transform.x) * (scaleRatio - 1);
          const newY = transform.y - (mouseY - transform.y) * (scaleRatio - 1);

          setTransform({
            x: newX,
            y: newY,
            scale: newScale,
          });
        };

        return (
          <div>
            <div className="header">
              <h1>PlantUML Diagram Viewer</h1>
            </div>
            <div className="container">
              <div className="sidebar">
                {loading ? (
                  <div>Loading...</div>
                ) : error ? (
                  <div className="error">{error}</div>
                ) : Object.keys(folders).length === 0 ? (
                  <div>No diagrams found</div>
                ) : (
                  Object.keys(folders).map((folder) => (
                    <div className="folder" key={folder}>
                      <div
                        className="folder-title"
                        onClick={() => toggleFolder(folder)}
                      >
                        {folder.charAt(0).toUpperCase() + folder.slice(1)}
                        <span>{expandedFolders[folder] ? "▼" : "▶"}</span>
                      </div>
                      {expandedFolders[folder] && (
                        <div className="diagram-list">
                          {folders[folder].map((diagram) => (
                            <div
                              className={`diagram-item ${
                                selectedFolder === folder &&
                                selectedDiagram === diagram
                                  ? "active"
                                  : ""
                              }`}
                              key={diagram}
                              onClick={() => selectDiagram(folder, diagram)}
                            >
                              {formatDiagramName(diagram)}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  ))
                )}
              </div>
              <div className="content">
                {loading ? (
                  <div className="loading">Loading diagrams...</div>
                ) : error ? (
                  <div className="error">{error}</div>
                ) : !selectedDiagram ? (
                  <div className="no-diagram">
                    Select a diagram from the sidebar
                  </div>
                ) : (
                  <div>
                    <div className="format-toggle">
                      <button
                        className={format === "png" ? "active" : ""}
                        onClick={() => setFormat("png")}
                      >
                        PNG
                      </button>
                      <button
                        className={format === "svg" ? "active" : ""}
                        onClick={() => setFormat("svg")}
                      >
                        SVG
                      </button>
                    </div>
                    <div className="zoom-controls">
                      <button onClick={zoomOut}>-</button>
                      <button onClick={resetView}>Reset</button>
                      <button onClick={zoomIn}>+</button>
                      <span style={{ marginLeft: "10px" }}>
                        {Math.round(transform.scale * 100)}%
                      </span>
                    </div>
                    <div className="diagram-container">
                      <div
                        ref={containerRef}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onWheel={handleWheel}
                        style={{
                          overflow: "hidden",
                          position: "relative",
                          height: "100%",
                          width: "100%",
                          cursor: isDragging ? "grabbing" : "grab",
                          userSelect: "none",
                        }}
                      >
                        <div
                          style={{
                            position: "absolute",
                            transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                            transformOrigin: "0 0",
                            transition: isDragging
                              ? "none"
                              : "transform 0.1s ease-out",
                          }}
                        >
                          <img
                            src={`http://localhost:8000/diagrams/${selectedFolder}/${selectedDiagram}.${format}`}
                            alt={formatDiagramName(selectedDiagram)}
                            style={{
                              maxWidth: "none",
                              display: "block",
                              pointerEvents: "none", // Prevents image from capturing mouse events
                            }}
                            onError={(e) => {
                              console.error(
                                `Failed to load image: ${e.target.src}`
                              );
                              // Try the alternative format
                              const altFormat =
                                format === "svg" ? "png" : "svg";
                              const altSrc = `http://localhost:8000/diagrams/${selectedFolder}/${selectedDiagram}.${altFormat}`;

                              // Set a flag to prevent infinite error loops
                              if (!e.target.getAttribute("data-tried-alt")) {
                                e.target.setAttribute("data-tried-alt", "true");
                                e.target.src = altSrc;
                              } else {
                                // If both formats fail, show a placeholder
                                e.target.src =
                                  "data:image/svg+xml;charset=utf-8,%3Csvg xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 viewBox%3D%220 0 400 300%22%3E%3Crect width%3D%22400%22 height%3D%22300%22 fill%3D%22%23f8f9fa%22%2F%3E%3Ctext x%3D%22150%22 y%3D%22150%22 font-family%3D%22Arial%22 font-size%3D%2220%22 fill%3D%22%23495057%22%3EDiagram not found%3C%2Ftext%3E%3C%2Fsvg%3E";
                                e.target.style.border = "1px dashed #dc3545";
                                e.target.style.padding = "20px";
                                e.target.style.boxSizing = "border-box";
                              }
                            }}
                          />
                        </div>
                        <div
                          className="zoom-info"
                          style={{
                            position: "absolute",
                            bottom: "10px",
                            right: "10px",
                            background: "rgba(255, 255, 255, 0.7)",
                            padding: "5px 10px",
                            borderRadius: "4px",
                            fontSize: "12px",
                          }}
                        >
                          {Math.round(transform.scale * 100)}%
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      // Render the app
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>



================================================================
End of Codebase
================================================================
